// vi: ts=4 sw=4
/**********************************************************************************************
*   raylib v5.0 - A simple and easy-to-use library to enjoy videogames programming (www.raylib.com)
*
*   FEATURES:
*       - NO external dependencies, all required libraries included with raylib
*       - Multiplatform: Windows, Linux, FreeBSD, OpenBSD, NetBSD, DragonFly,
*                        MacOS, Haiku, Android, Raspberry Pi, DRM native, HTML5.
*       - Written in plain C code (C99) in PascalCase/camelCase notation
*       - Hardware accelerated with OpenGL (1.1, 2.1, 3.3, 4.3 or ES2 - choose at compile)
*       - Unique OpenGL abstraction layer (usable as standalone module): [rlgl]
*       - Multiple Fonts formats supported (TTF, XNA fonts, AngelCode fonts)
*       - Outstanding texture formats support, including compressed formats (DXT, ETC, ASTC)
*       - Full 3d support for 3d Shapes, Models, Billboards, Heightmaps and more!
*       - Flexible Materials system, supporting classic maps and PBR maps
*       - Animated 3D models supported (skeletal bones animation) (IQM)
*       - Shaders support, including Model shaders and Postprocessing shaders
*       - Powerful math module for Vector, Matrix and Quaternion operations: [raymath]
*       - Audio loading and playing with streaming support (WAV, OGG, MP3, FLAC, XM, MOD)
*       - VR stereo rendering with configurable HMD device parameters
*       - Bindings to multiple programming languages available!
*
*   NOTES:
*       - One default Font is loaded on InitWindow()->LoadFontDefault() [core, text]
*       - One default Texture2D is loaded on rlglInit(), 1x1 white pixel R8G8B8A8 [rlgl] (OpenGL 3.3 or ES2)
*       - One default Shader is loaded on rlglInit()->rlLoadShaderDefault() [rlgl] (OpenGL 3.3 or ES2)
*       - One default RenderBatch is loaded on rlglInit()->rlLoadRenderBatch() [rlgl] (OpenGL 3.3 or ES2)
*
*   DEPENDENCIES (included):
*       [rcore] rglfw (Camilla LÃ¶wy - github.com/glfw/glfw) for window/context management and input (PLATFORM_DESKTOP)
*       [rlgl] glad (David Herberth - github.com/Dav1dde/glad) for OpenGL 3.3 extensions loading (PLATFORM_DESKTOP)
*       [raudio] miniaudio (David Reid - github.com/mackron/miniaudio) for audio device/context management
*
*   OPTIONAL DEPENDENCIES (included):
*       [rcore] msf_gif (Miles Fogle) for GIF recording
*       [rcore] sinfl (Micha Mettke) for DEFLATE decompression algorithm
*       [rcore] sdefl (Micha Mettke) for DEFLATE compression algorithm
*       [rtextures] stb_image (Sean Barret) for images loading (BMP, TGA, PNG, JPEG, HDR...)
*       [rtextures] stb_image_write (Sean Barret) for image writing (BMP, TGA, PNG, JPG)
*       [rtextures] stb_image_resize (Sean Barret) for image resizing algorithms
*       [rtext] stb_truetype (Sean Barret) for ttf fonts loading
*       [rtext] stb_rect_pack (Sean Barret) for rectangles packing
*       [rmodels] par_shapes (Philip Rideout) for parametric 3d shapes generation
*       [rmodels] tinyobj_loader_c (Syoyo Fujita) for models loading (OBJ, MTL)
*       [rmodels] cgltf (Johannes Kuhlmann) for models loading (glTF)
*       [rmodels] Model3D (bzt) for models loading (M3D, https://bztsrc.gitlab.io/model3d)
*       [raudio] dr_wav (David Reid) for WAV audio file loading
*       [raudio] dr_flac (David Reid) for FLAC audio file loading
*       [raudio] dr_mp3 (David Reid) for MP3 audio file loading
*       [raudio] stb_vorbis (Sean Barret) for OGG audio loading
*       [raudio] jar_xm (Joshua Reisenauer) for XM audio module loading
*       [raudio] jar_mod (Joshua Reisenauer) for MOD audio module loading
*
*   SECTIONS:
*       // Some basic Defines
*       // Structures Definition
*       // Enumerators Definition
*       // Window-related functions
*       // Cursor-related functions
*       // Drawing-related functions
*       // VR stereo config functions for VR simulator
*       // Shader management functions
*       // Screen-space-related functions
*       // Timing-related functions
*       // Custom frame control functions
*       // Random values generation functions
*       // Misc. functions
*       // Set custom callbacks
*       // Files management functions
*       // File system functions
*       // Compression/Encoding functionality
*       // Automation events functionality
*       // Input-related functions: keyboard
*       // Input-related functions: gamepads
*       // Input-related functions: mouse
*       // Input-related functions: touch
*       // Gestures and Touch Handling Functions (Module: rgestures)
*       // Camera System Functions (Module: rcamera)
*       // Basic Shapes Drawing Functions (Module: shapes)
*       // Basic shapes drawing functions
*       // Splines drawing functions
*       // Spline segment point evaluation functions, for a given t [0.0f .. 1.0f]
*       // Basic shapes collision detection functions
*       // Image loading functions
*       // Image generation functions
*       // Image manipulation functions
*       // Image drawing functions
*       // Texture loading functions
*       // Texture configuration functions
*       // Texture drawing functions
*       // Color/pixel related functions
*       // Font loading/unloading functions
*       // Text drawing functions
*       // Text font info functions
*       // Text codepoints management functions (unicode characters)
*       // Text strings management functions (no UTF-8 strings, only byte chars)
*       // Basic geometric 3D shapes drawing functions
*       // Model management functions
*       // Model drawing functions
*       // Mesh management functions
*       // Mesh generation functions
*       // Material loading/unloading functions
*       // Model animations loading/unloading functions
*       // Collision detection functions
*       // Audio device management functions
*       // Wave/Sound loading/unloading functions
*       // Wave/Sound management functions
*       // Music management functions
*       // AudioStream management functions
*
**********************************************************************************************/
module rl;
import std::math;

const RAYLIB_VERSION_MAJOR = 5;
const RAYLIB_VERSION_MINOR = 0;
const RAYLIB_VERSION_PATCH = 0;
const RAYLIB_VERSION = "5.0";

//----------------------------------------------------------------------------------
// Some basic Defines
//----------------------------------------------------------------------------------
const PI = math::PI;
const DEG2RAD = (PI/180.0f);
const RAD2DEG = (180.0f/PI);

// Some Basic Colors
// NOTE: Custom raylib color palette for amazing visuals on WHITE background
const LIGHTGRAY  = Color { 200, 200, 200, 255 };   // Light Gray
const GRAY       = Color { 130, 130, 130, 255 };   // Gray
const DARKGRAY   = Color { 80, 80, 80, 255 };      // Dark Gray
const YELLOW     = Color { 253, 249, 0, 255 };     // Yellow
const GOLD       = Color { 255, 203, 0, 255 };     // Gold
const ORANGE     = Color { 255, 161, 0, 255 };     // Orange
const PINK       = Color { 255, 109, 194, 255 };   // Pink
const RED        = Color { 230, 41, 55, 255 };     // Red
const MAROON     = Color { 190, 33, 55, 255 };     // Maroon
const GREEN      = Color { 0, 228, 48, 255 };      // Green
const LIME       = Color { 0, 158, 47, 255 };      // Lime
const DARKGREEN  = Color { 0, 117, 44, 255 };      // Dark Green
const SKYBLUE    = Color { 102, 191, 255, 255 };   // Sky Blue
const BLUE       = Color { 0, 121, 241, 255 };     // Blue
const DARKBLUE   = Color { 0, 82, 172, 255 };      // Dark Blue
const PURPLE     = Color { 200, 122, 255, 255 };   // Purple
const VIOLET     = Color { 135, 60, 190, 255 };    // Violet
const DARKPURPLE = Color { 112, 31, 126, 255 };    // Dark Purple
const BEIGE      = Color { 211, 176, 131, 255 };   // Beige
const BROWN      = Color { 127, 106, 79, 255 };    // Brown
const DARKBROWN  = Color { 76, 63, 47, 255 };      // Dark Brown

const WHITE      = Color { 255, 255, 255, 255 };   // White
const BLACK      = Color { 0, 0, 0, 255 };         // Black
const BLANK      = Color { 0, 0, 0, 0 };           // Blank (Transparent)
const MAGENTA    = Color { 255, 0, 255, 255 };     // Magenta
const RAYWHITE   = Color { 245, 245, 245, 255 };   // My own White (raylib logo)

//----------------------------------------------------------------------------------
// Structures Definition
//----------------------------------------------------------------------------------

// Vector2, 2 components
struct Vector2 {
	float x;                // Vector x component
	float y;                // Vector y component
}

// Vector3, 3 components
struct Vector3 {
	float x;                // Vector x component
	float y;                // Vector y component
	float z;                // Vector z component
}

// Vector4, 4 components
struct Vector4 {
	float x;                // Vector x component
	float y;                // Vector y component
	float z;                // Vector z component
	float w;                // Vector w component
}

// Quaternion, 4 components (Vector4 alias)
def Quaternion = Vector4;

// Matrix, 4x4 components, column major, OpenGL style, right-handed
struct Matrix {
	float m0, m4, m8, m12;  // Matrix first row (4 components)
	float m1, m5, m9, m13;  // Matrix second row (4 components)
	float m2, m6, m10, m14; // Matrix third row (4 components)
	float m3, m7, m11, m15; // Matrix fourth row (4 components)
}

// Color, 4 components, R8G8B8A8 (32bit)
struct Color {
	char r;        // Color red value
	char g;        // Color green value
	char b;        // Color blue value
	char a;        // Color alpha value
}

// Rectangle, 4 components
struct Rectangle {
	float x;                // Rectangle top-left corner position x
	float y;                // Rectangle top-left corner position y
	float width;            // Rectangle width
	float height;           // Rectangle height
}

// Image, pixel data stored in CPU memory (RAM)
struct Image {
	void* data;             // Image raw data
	int width;              // Image base width
	int height;             // Image base height
	int mipmaps;            // Mipmap levels, 1 by default
	PixelFormat format;     // Data format (PixelFormat type)
}

// Texture, tex data stored in GPU memory (VRAM)
struct Texture {
	uint id;                // OpenGL texture id
	int width;              // Texture base width
	int height;             // Texture base height
	int mipmaps;            // Mipmap levels, 1 by default
	PixelFormat format;     // Data format (PixelFormat type)
}

// Texture2D, same as Texture
def Texture2D = Texture;

// TextureCubemap, same as Texture
def TextureCubemap = Texture;

// RenderTexture, fbo for texture rendering
struct RenderTexture {
	uint id;                // OpenGL framebuffer object id
	Texture texture;        // Color buffer attachment texture
	Texture depth;          // Depth buffer attachment texture
}

// RenderTexture2D, same as RenderTexture
def RenderTexture2D = RenderTexture;

// NPatchInfo, n-patch layout info
struct NPatchInfo {
	Rectangle source;       // Texture source rectangle
	int left;               // Left border offset
	int top;                // Top border offset
	int right;              // Right border offset
	int bottom;             // Bottom border offset
	NPatchLayout layout;    // Layout of the n-patch: 3x3, 1x3 or 3x1
}

// GlyphInfo, font characters glyphs info
struct GlyphInfo {
	int value;              // Character value (Unicode)
	int offset_x;           // Character offset X when drawing
	int offset_y;           // Character offset Y when drawing
	int advance_x;          // Character advance position X
	Image image;            // Character image data
}

// Font, font texture and GlyphInfo array data
struct Font {
	int base_size;          // Base size (default chars height)
	int glyph_count;        // Number of glyph characters
	int glyph_padding;      // Padding around the glyph characters
	Texture2D texture;      // Texture atlas containing the glyphs
	Rectangle* recs;        // Rectangles in texture for the glyphs
	GlyphInfo* glyphs;      // Glyphs info data
}

// Camera, defines position/orientation in 3d space
struct Camera3D {
	Vector3 position;       // Camera position
	Vector3 target;         // Camera target it looks-at
	Vector3 up;             // Camera up vector (rotation over its axis)
	float fovy;             // Camera field-of-view aperture in Y (degrees) in perspective, used as near plane width in orthographic
	int projection;         // Camera projection: CAMERA_PERSPECTIVE or CAMERA_ORTHOGRAPHIC
}

def Camera = Camera3D;    // Camera type fallback, defaults to Camera3D

// Camera2D, defines position/orientation in 2d space
struct Camera2D {
	Vector2 offset;         // Camera offset (displacement from target)
	Vector2 target;         // Camera target (rotation and zoom origin)
	float rotation;         // Camera rotation in degrees
	float zoom;             // Camera zoom (scaling), should be 1.0f by default
}

// Mesh, vertex data and vao/vbo
struct Mesh {
	int vertex_count;        // Number of vertices stored in arrays
	int triangle_count;      // Number of triangles stored (indexed or not)

	// Vertex attributes data
	float* vertices;        // Vertex position (XYZ - 3 components per vertex) (shader-location = 0)
	float* texcoords;       // Vertex texture coordinates (UV - 2 components per vertex) (shader-location = 1)
	float* texcoords2;      // Vertex texture second coordinates (UV - 2 components per vertex) (shader-location = 5)
	float* normals;         // Vertex normals (XYZ - 3 components per vertex) (shader-location = 2)
	float* tangents;        // Vertex tangents (XYZW - 4 components per vertex) (shader-location = 4)
	char* colors;           // Vertex colors (RGBA - 4 components per vertex) (shader-location = 3)
	ushort* indices;        // Vertex indices (in case vertex data comes indexed)

	// Animation vertex data
	float* anim_vertices;    // Animated vertex positions (after bones transformations)
	float* anim_normals;     // Animated normals (after bones transformations)
	char* bone_ids;          // Vertex bone ids, max 255 bone ids, up to 4 bones influence by vertex (skinning)
	float* bone_weights;     // Vertex bone weight, up to 4 bones influence by vertex (skinning)

	// OpenGL identifiers
	uint vao_id;             // OpenGL Vertex Array Object id
	uint* vbo_id;            // OpenGL Vertex Buffer Objects id (default vertex data)
}

// Shader
struct Shader {
	uint id;                // Shader program id
	int* locs;              // Shader locations array (RL_MAX_SHADER_LOCATIONS)
}

// MaterialMap
struct MaterialMap {
	Texture2D texture;      // Material map texture
	Color color;            // Material map color
	float value;            // Material map value
}

// Material, includes shader and maps
struct Material {
	Shader shader;          // Material shader
	MaterialMap* maps;      // Material maps array (MAX_MATERIAL_MAPS)
	float[4] params;        // Material generic parameters (if required)
}

// Transform, vertex transformation data
struct Transform {
	Vector3 translation;    // Translation
	Quaternion rotation;    // Rotation
	Vector3 scale;          // Scale
}

// Bone, skeletal animation bone
struct BoneInfo {
	char[32] name;          // Bone name
	int parent;             // Bone parent
}

// Model, meshes, materials and animation data
struct Model {
	Matrix transform;     // Local transform matrix

	int mesh_count;       // Number of meshes
	int material_count;   // Number of materials
	Mesh* meshes;         // Meshes array
	Material* materials;  // Materials array
	int* mesh_material;   // Mesh material number

	// Animation data
	int bone_count;       // Number of bones
	BoneInfo* bones;      // Bones information (skeleton)
	Transform* bind_pose; // Bones base transformation (pose)
}

// ModelAnimation
struct ModelAnimation {
	int bone_count;          // Number of bones
	int frame_count;         // Number of animation frames
	BoneInfo* bones;         // Bones information (skeleton)
	Transform** frame_poses; // Poses array by frame
	char[32] name;           // Animation name
}

// Ray, ray for raycasting
struct Ray {
	Vector3 position;  // Ray position (origin)
	Vector3 direction; // Ray direction
}

// RayCollision, ray hit information
struct RayCollision {
	bool hit;       // Did the ray hit something?
	float distance; // Distance to the nearest hit
	Vector3 point;  // Point of the nearest hit
	Vector3 normal; // Surface normal of hit
}

// BoundingBox
struct BoundingBox {
	Vector3 min; // Minimum vertex box-corner
	Vector3 max; // Maximum vertex box-corner
}

// Wave, audio wave data
struct Wave {
	uint frame_count; // Total number of frames (considering channels)
	uint sample_rate; // Frequency (samples per second)
	uint sample_size; // Bit depth (bits per sample): 8, 16, 32 (24 not supported)
	uint channels;    // Number of channels (1-mono, 2-stereo, ...)
	void* data;       // Buffer data pointer
}

// Opaque structs declaration
// NOTE: Actual structs are defined internally in raudio module
distinct AudioBufferRef = void*;
distinct AudioProcessorRef = void*;

// AudioStream, custom audio stream
struct AudioStream {
	AudioBufferRef buffer;       // Pointer to internal data used by the audio system
	AudioProcessorRef processor; // Pointer to internal data processor, useful for audio effects

	uint sample_rate;            // Frequency (samples per second)
	uint sample_size;            // Bit depth (bits per sample): 8, 16, 32 (24 not supported)
	uint channels;               // Number of channels (1-mono, 2-stereo, ...)
}

// Sound
struct Sound {
	AudioStream stream; // Audio stream
	uint frame_count;   // Total number of frames (considering channels)
}

// Music, audio stream, anything longer than ~10 seconds should be streamed
struct Music {
	AudioStream stream; // Audio stream
	uint frame_count;   // Total number of frames (considering channels)
	bool looping;       // Music looping enable

	int ctx_type;       // Type of music context (audio filetype)
	void* ctx_data;     // Audio context data, depends on type
}

// VrDeviceInfo, Head-Mounted-Display device parameters
struct VrDeviceInfo {
	int h_resolution;                // Horizontal resolution in pixels
	int v_resolution;                // Vertical resolution in pixels
	float h_screen_size;             // Horizontal size in meters
	float v_screen_size;             // Vertical size in meters
	float v_screen_center;           // Screen center in meters
	float eye_to_screen_distance;    // Distance between eye and display in meters
	float lens_separation_distance;  // Lens separation distance in meters
	float interpupillary_distance;   // IPD (distance between pupils) in meters
	float[4] lens_distortion_values; // Lens distortion constant parameters
	float[4] chroma_ab_correction;   // Chromatic aberration correction parameters
}

// VrStereoConfig, VR stereo rendering configuration for simulator
struct VrStereoConfig {
	Matrix[2] projection;         // VR projection matrices (per eye)
	Matrix[2] view_offset;        // VR view offset matrices (per eye)
	float[2] left_lens_center;    // VR left lens center
	float[2] right_lens_center;   // VR right lens center
	float[2] left_screen_center;  // VR left screen center
	float[2] right_screen_center; // VR right screen center
	float[2] scale;               // VR distortion scale
	float[2] scale_in;            // VR distortion scale in
}

// File path list
struct FilePathList {
	uint capacity;        // Filepaths max entries
	uint count;           // Filepaths entries count
	char** paths;         // Filepaths entries
}

// Automation event
struct AutomationEvent {
	uint frame;             // Event frame
	uint type;              // Event type (AutomationEventType)
	int[4] params;          // Event parameters (if required)
}

// Automation event list
struct AutomationEventList {
	uint capacity;           // Events max entries (MAX_AUTOMATION_EVENTS)
	uint count;              // Events entries count
	AutomationEvent* events; // Events entries
}

//----------------------------------------------------------------------------------
// Enumerators Definition
//----------------------------------------------------------------------------------
// System/Window config flags
// NOTE: Every bit registers one state (use it with bit masks)
// By default all flags are set to 0
distinct ConfigFlags = uint;
const ConfigFlags FLAG_VSYNC_HINT         = 0x00000040;   // Set to try enabling V-Sync on GPU
const ConfigFlags FLAG_FULLSCREEN_MODE    = 0x00000002;   // Set to run program in fullscreen
const ConfigFlags FLAG_WINDOW_RESIZABLE   = 0x00000004;   // Set to allow resizable window
const ConfigFlags FLAG_WINDOW_UNDECORATED = 0x00000008;   // Set to disable window decoration (frame and buttons)
const ConfigFlags FLAG_WINDOW_HIDDEN      = 0x00000080;   // Set to hide window
const ConfigFlags FLAG_WINDOW_MINIMIZED   = 0x00000200;   // Set to minimize window (iconify)
const ConfigFlags FLAG_WINDOW_MAXIMIZED   = 0x00000400;   // Set to maximize window (expanded to monitor)
const ConfigFlags FLAG_WINDOW_UNFOCUSED   = 0x00000800;   // Set to window non focused
const ConfigFlags FLAG_WINDOW_TOPMOST     = 0x00001000;   // Set to window always on top
const ConfigFlags FLAG_WINDOW_ALWAYS_RUN  = 0x00000100;   // Set to allow windows running while minimized
const ConfigFlags FLAG_WINDOW_TRANSPARENT = 0x00000010;   // Set to allow transparent framebuffer
const ConfigFlags FLAG_WINDOW_HIGHDPI     = 0x00002000;   // Set to support HighDPI
const ConfigFlags FLAG_WINDOW_MOUSE_PASSTHROUGH = 0x00004000; // Set to support mouse passthrough, only supported when FLAG_WINDOW_UNDECORATED
const ConfigFlags FLAG_BORDERLESS_WINDOWED_MODE = 0x00008000; // Set to run program in borderless windowed mode
const ConfigFlags FLAG_MSAA_4X_HINT       = 0x00000020;   // Set to try enabling MSAA 4X
const ConfigFlags FLAG_INTERLACED_HINT    = 0x00010000;   // Set to try enabling interlaced video format (for V3D)

// Trace log level
// NOTE: Organized by priority level
enum TraceLogLevel : uint {
	ALL,            // Display all logs (0)
	TRACE,          // Trace logging, intended for internal use only
	DEBUG,          // Debug logging, used for internal debugging, it should be disabled on release builds
	INFO,           // Info logging, used for program execution info
	WARNING,        // Warning logging, used on recoverable failures
	ERROR,          // Error logging, used on unrecoverable failures
	FATAL,          // Fatal logging, used to abort program: exit(EXIT_FAILURE)
	NONE            // Disable logging
}

$assert((uint)TraceLogLevel.ALL == 0);

// Keyboard keys (US keyboard layout)
// NOTE: Use GetKeyPressed() to allow redefining
// required keys for alternative layouts
distinct KeyboardKey = uint;
const KeyboardKey KEY_NULL            = 0;        // Key: NULL, used for no key pressed
// Alphanumeric keys
const KeyboardKey KEY_APOSTROPHE      = 39;       // Key: '
const KeyboardKey KEY_COMMA           = 44;       // Key: ,
const KeyboardKey KEY_MINUS           = 45;       // Key: -
const KeyboardKey KEY_PERIOD          = 46;       // Key: .
const KeyboardKey KEY_SLASH           = 47;       // Key: /
const KeyboardKey KEY_ZERO            = 48;       // Key: 0
const KeyboardKey KEY_ONE             = 49;       // Key: 1
const KeyboardKey KEY_TWO             = 50;       // Key: 2
const KeyboardKey KEY_THREE           = 51;       // Key: 3
const KeyboardKey KEY_FOUR            = 52;       // Key: 4
const KeyboardKey KEY_FIVE            = 53;       // Key: 5
const KeyboardKey KEY_SIX             = 54;       // Key: 6
const KeyboardKey KEY_SEVEN           = 55;       // Key: 7
const KeyboardKey KEY_EIGHT           = 56;       // Key: 8
const KeyboardKey KEY_NINE            = 57;       // Key: 9
const KeyboardKey KEY_SEMICOLON       = 59;       // Key: ;
const KeyboardKey KEY_EQUAL           = 61;       // Key: =
const KeyboardKey KEY_A               = 65;       // Key: A | a
const KeyboardKey KEY_B               = 66;       // Key: B | b
const KeyboardKey KEY_C               = 67;       // Key: C | c
const KeyboardKey KEY_D               = 68;       // Key: D | d
const KeyboardKey KEY_E               = 69;       // Key: E | e
const KeyboardKey KEY_F               = 70;       // Key: F | f
const KeyboardKey KEY_G               = 71;       // Key: G | g
const KeyboardKey KEY_H               = 72;       // Key: H | h
const KeyboardKey KEY_I               = 73;       // Key: I | i
const KeyboardKey KEY_J               = 74;       // Key: J | j
const KeyboardKey KEY_K               = 75;       // Key: K | k
const KeyboardKey KEY_L               = 76;       // Key: L | l
const KeyboardKey KEY_M               = 77;       // Key: M | m
const KeyboardKey KEY_N               = 78;       // Key: N | n
const KeyboardKey KEY_O               = 79;       // Key: O | o
const KeyboardKey KEY_P               = 80;       // Key: P | p
const KeyboardKey KEY_Q               = 81;       // Key: Q | q
const KeyboardKey KEY_R               = 82;       // Key: R | r
const KeyboardKey KEY_S               = 83;       // Key: S | s
const KeyboardKey KEY_T               = 84;       // Key: T | t
const KeyboardKey KEY_U               = 85;       // Key: U | u
const KeyboardKey KEY_V               = 86;       // Key: V | v
const KeyboardKey KEY_W               = 87;       // Key: W | w
const KeyboardKey KEY_X               = 88;       // Key: X | x
const KeyboardKey KEY_Y               = 89;       // Key: Y | y
const KeyboardKey KEY_Z               = 90;       // Key: Z | z
const KeyboardKey KEY_LEFT_BRACKET    = 91;       // Key: [
const KeyboardKey KEY_BACKSLASH       = 92;       // Key: '\'
const KeyboardKey KEY_RIGHT_BRACKET   = 93;       // Key: ]
const KeyboardKey KEY_GRAVE           = 96;       // Key: `
// Function keys
const KeyboardKey KEY_SPACE           = 32;       // Key: Space
const KeyboardKey KEY_ESCAPE          = 256;      // Key: Esc
const KeyboardKey KEY_ENTER           = 257;      // Key: Enter
const KeyboardKey KEY_TAB             = 258;      // Key: Tab
const KeyboardKey KEY_BACKSPACE       = 259;      // Key: Backspace
const KeyboardKey KEY_INSERT          = 260;      // Key: Ins
const KeyboardKey KEY_DELETE          = 261;      // Key: Del
const KeyboardKey KEY_RIGHT           = 262;      // Key: Cursor right
const KeyboardKey KEY_LEFT            = 263;      // Key: Cursor left
const KeyboardKey KEY_DOWN            = 264;      // Key: Cursor down
const KeyboardKey KEY_UP              = 265;      // Key: Cursor up
const KeyboardKey KEY_PAGE_UP         = 266;      // Key: Page up
const KeyboardKey KEY_PAGE_DOWN       = 267;      // Key: Page down
const KeyboardKey KEY_HOME            = 268;      // Key: Home
const KeyboardKey KEY_END             = 269;      // Key: End
const KeyboardKey KEY_CAPS_LOCK       = 280;      // Key: Caps lock
const KeyboardKey KEY_SCROLL_LOCK     = 281;      // Key: Scroll down
const KeyboardKey KEY_NUM_LOCK        = 282;      // Key: Num lock
const KeyboardKey KEY_PRINT_SCREEN    = 283;      // Key: Print screen
const KeyboardKey KEY_PAUSE           = 284;      // Key: Pause
const KeyboardKey KEY_F1              = 290;      // Key: F1
const KeyboardKey KEY_F2              = 291;      // Key: F2
const KeyboardKey KEY_F3              = 292;      // Key: F3
const KeyboardKey KEY_F4              = 293;      // Key: F4
const KeyboardKey KEY_F5              = 294;      // Key: F5
const KeyboardKey KEY_F6              = 295;      // Key: F6
const KeyboardKey KEY_F7              = 296;      // Key: F7
const KeyboardKey KEY_F8              = 297;      // Key: F8
const KeyboardKey KEY_F9              = 298;      // Key: F9
const KeyboardKey KEY_F10             = 299;      // Key: F10
const KeyboardKey KEY_F11             = 300;      // Key: F11
const KeyboardKey KEY_F12             = 301;      // Key: F12
const KeyboardKey KEY_LEFT_SHIFT      = 340;      // Key: Shift left
const KeyboardKey KEY_LEFT_CONTROL    = 341;      // Key: Control left
const KeyboardKey KEY_LEFT_ALT        = 342;      // Key: Alt left
const KeyboardKey KEY_LEFT_SUPER      = 343;      // Key: Super left
const KeyboardKey KEY_RIGHT_SHIFT     = 344;      // Key: Shift right
const KeyboardKey KEY_RIGHT_CONTROL   = 345;      // Key: Control right
const KeyboardKey KEY_RIGHT_ALT       = 346;      // Key: Alt right
const KeyboardKey KEY_RIGHT_SUPER     = 347;      // Key: Super right
const KeyboardKey KEY_KB_MENU         = 348;      // Key: KB menu
// Keypad keys
const KeyboardKey KEY_KP_0            = 320;      // Key: Keypad 0
const KeyboardKey KEY_KP_1            = 321;      // Key: Keypad 1
const KeyboardKey KEY_KP_2            = 322;      // Key: Keypad 2
const KeyboardKey KEY_KP_3            = 323;      // Key: Keypad 3
const KeyboardKey KEY_KP_4            = 324;      // Key: Keypad 4
const KeyboardKey KEY_KP_5            = 325;      // Key: Keypad 5
const KeyboardKey KEY_KP_6            = 326;      // Key: Keypad 6
const KeyboardKey KEY_KP_7            = 327;      // Key: Keypad 7
const KeyboardKey KEY_KP_8            = 328;      // Key: Keypad 8
const KeyboardKey KEY_KP_9            = 329;      // Key: Keypad 9
const KeyboardKey KEY_KP_DECIMAL      = 330;      // Key: Keypad .
const KeyboardKey KEY_KP_DIVIDE       = 331;      // Key: Keypad /
const KeyboardKey KEY_KP_MULTIPLY     = 332;      // Key: Keypad *
const KeyboardKey KEY_KP_SUBTRACT     = 333;      // Key: Keypad -
const KeyboardKey KEY_KP_ADD          = 334;      // Key: Keypad +
const KeyboardKey KEY_KP_ENTER        = 335;      // Key: Keypad Enter
const KeyboardKey KEY_KP_EQUAL        = 336;      // Key: Keypad =
// Android key buttons
const KeyboardKey KEY_BACK            = 4;        // Key: Android back button
const KeyboardKey KEY_MENU            = 82;       // Key: Android menu button
const KeyboardKey KEY_VOLUME_UP       = 24;       // Key: Android volume up button
const KeyboardKey KEY_VOLUME_DOWN     = 25;       // Key: Android volume down button

// Mouse buttons
enum MouseButton : uint {
	LEFT,    // Mouse button left
	RIGHT,   // Mouse button right
	MIDDLE,  // Mouse button middle (pressed wheel)
	SIDE,    // Mouse button side (advanced mouse device)
	EXTRA,   // Mouse button extra (advanced mouse device)
	FORWARD, // Mouse button forward (advanced mouse device)
	BACK,    // Mouse button back (advanced mouse device)
}

$assert((uint)MouseButton.LEFT == 0);

// Mouse cursor
enum MouseCursor : uint {
	DEFAULT,       // Default pointer shape
	ARROW,         // Arrow shape
	IBEAM,         // Text writing cursor shape
	CROSSHAIR,     // Cross shape
	POINTING_HAND, // Pointing hand cursor
	RESIZE_EW,     // Horizontal resize/move arrow shape
	RESIZE_NS,     // Vertical resize/move arrow shape
	RESIZE_NWSE,   // Top-left to bottom-right diagonal resize/move arrow shape
	RESIZE_NESW,   // The top-right to bottom-left diagonal resize/move arrow shape
	RESIZE_ALL,    // The omnidirectional resize/move cursor shape
	NOT_ALLOWED,   // The operation-not-allowed shape
}

$assert((uint)MouseCursor.DEFAULT == 0);

// Gamepad buttons
enum GamepadButton : uint {
	UNKNOWN,             // Unknown button, just for error checking
	LEFT_FACE_UP,        // Gamepad left DPAD up button
	LEFT_FACE_RIGHT,     // Gamepad left DPAD right button
	LEFT_FACE_DOWN,      // Gamepad left DPAD down button
	LEFT_FACE_LEFT,      // Gamepad left DPAD left button
	RIGHT_FACE_UP,       // Gamepad right button up (i.e. PS3: Triangle, Xbox: Y)
	RIGHT_FACE_RIGHT,    // Gamepad right button right (i.e. PS3: Square, Xbox: X)
	RIGHT_FACE_DOWN,     // Gamepad right button down (i.e. PS3: Cross, Xbox: A)
	RIGHT_FACE_LEFT,     // Gamepad right button left (i.e. PS3: Circle, Xbox: B)
	LEFT_TRIGGER_1,      // Gamepad top/back trigger left (first), it could be a trailing button
	LEFT_TRIGGER_2,      // Gamepad top/back trigger left (second), it could be a trailing button
	RIGHT_TRIGGER_1,     // Gamepad top/back trigger right (one), it could be a trailing button
	RIGHT_TRIGGER_2,     // Gamepad top/back trigger right (second), it could be a trailing button
	MIDDLE_LEFT,         // Gamepad center buttons, left one (i.e. PS3: Select)
	MIDDLE,              // Gamepad center buttons, middle one (i.e. PS3: PS, Xbox: XBOX)
	MIDDLE_RIGHT,        // Gamepad center buttons, right one (i.e. PS3: Start)
	LEFT_THUMB,          // Gamepad joystick pressed button left
	RIGHT_THUMB,         // Gamepad joystick pressed button right
}

$assert((uint)GamepadButton.UNKNOWN == 0);

// Gamepad axis
enum GamepadAxis : uint {
	LEFT_X,        // Gamepad left stick X axis
	LEFT_Y,        // Gamepad left stick Y axis
	RIGHT_X,       // Gamepad right stick X axis
	RIGHT_Y,       // Gamepad right stick Y axis
	LEFT_TRIGGER,  // Gamepad back trigger left, pressure level: [1..-1]
	RIGHT_TRIGGER, // Gamepad back trigger right, pressure level: [1..-1]
}

$assert((uint)GamepadAxis.LEFT_X == 0);

// Material map index
enum MaterialMapIndex : uint {
	ALBEDO,            // Albedo material (same as: MATERIAL_MAP_DIFFUSE)
	METALNESS,         // Metalness material (same as: MATERIAL_MAP_SPECULAR)
	NORMAL,            // Normal material
	ROUGHNESS,         // Roughness material
	OCCLUSION,         // Ambient occlusion material
	EMISSION,          // Emission material
	HEIGHT,            // Heightmap material
	CUBEMAP,           // Cubemap material (NOTE: Uses GL_TEXTURE_CUBE_MAP)
	IRRADIANCE,        // Irradiance material (NOTE: Uses GL_TEXTURE_CUBE_MAP)
	PREFILTER,         // Prefilter material (NOTE: Uses GL_TEXTURE_CUBE_MAP)
	BRDF,              // Brdf material
}

$assert((uint)MaterialMapIndex.ALBEDO == 0);

// Shader location index
enum ShaderLocationIndex : uint {
	VERTEX_POSITION,     // Shader location: vertex attribute: position
	VERTEX_TEXCOORD01,   // Shader location: vertex attribute: texcoord01
	VERTEX_TEXCOORD02,   // Shader location: vertex attribute: texcoord02
	VERTEX_NORMAL,       // Shader location: vertex attribute: normal
	VERTEX_TANGENT,      // Shader location: vertex attribute: tangent
	VERTEX_COLOR,        // Shader location: vertex attribute: color
	MATRIX_MVP,          // Shader location: matrix uniform: model-view-projection
	MATRIX_VIEW,         // Shader location: matrix uniform: view (camera transform)
	MATRIX_PROJECTION,   // Shader location: matrix uniform: projection
	MATRIX_MODEL,        // Shader location: matrix uniform: model (transform)
	MATRIX_NORMAL,       // Shader location: matrix uniform: normal
	VECTOR_VIEW,         // Shader location: vector uniform: view
	COLOR_DIFFUSE,       // Shader location: vector uniform: diffuse color
	COLOR_SPECULAR,      // Shader location: vector uniform: specular color
	COLOR_AMBIENT,       // Shader location: vector uniform: ambient color
	MAP_ALBEDO,          // Shader location: sampler2d texture: albedo (same as: SHADER_LOC_MAP_DIFFUSE)
	MAP_METALNESS,       // Shader location: sampler2d texture: metalness (same as: SHADER_LOC_MAP_SPECULAR)
	MAP_NORMAL,          // Shader location: sampler2d texture: normal
	MAP_ROUGHNESS,       // Shader location: sampler2d texture: roughness
	MAP_OCCLUSION,       // Shader location: sampler2d texture: occlusion
	MAP_EMISSION,        // Shader location: sampler2d texture: emission
	MAP_HEIGHT,          // Shader location: sampler2d texture: height
	MAP_CUBEMAP,         // Shader location: samplerCube texture: cubemap
	MAP_IRRADIANCE,      // Shader location: samplerCube texture: irradiance
	MAP_PREFILTER,       // Shader location: samplerCube texture: prefilter
	MAP_BRDF,            // Shader location: sampler2d texture: brdf
}

$assert((uint)ShaderLocationIndex.VERTEX_POSITION == 0);

// Shader uniform data type
enum ShaderUniformDataType : uint {
	FLOAT,           // Shader uniform type: float
	VEC2,            // Shader uniform type: vec2 (2 float)
	VEC3,            // Shader uniform type: vec3 (3 float)
	VEC4,            // Shader uniform type: vec4 (4 float)
	INT,             // Shader uniform type: int
	IVEC2,           // Shader uniform type: ivec2 (2 int)
	IVEC3,           // Shader uniform type: ivec3 (3 int)
	IVEC4,           // Shader uniform type: ivec4 (4 int)
	SAMPLER2D,       // Shader uniform type: sampler2d
}

$assert((uint)ShaderUniformDataType.FLOAT == 0);

// Shader attribute data types
enum ShaderAttributeDataType : uint {
	FLOAT,        // Shader attribute type: float
	VEC2,             // Shader attribute type: vec2 (2 float)
	VEC3,             // Shader attribute type: vec3 (3 float)
	VEC4              // Shader attribute type: vec4 (4 float)
}

$assert((uint)ShaderAttributeDataType.FLOAT == 0);

// Pixel formats
// NOTE: Support depends on OpenGL version and platform
enum PixelFormat : uint {
	NONE,
	UNCOMPRESSED_GRAYSCALE,     // 8 bit per pixel (no alpha)
	UNCOMPRESSED_GRAY_ALPHA,    // 8*2 bpp (2 channels)
	UNCOMPRESSED_R5G6B5,        // 16 bpp
	UNCOMPRESSED_R8G8B8,        // 24 bpp
	UNCOMPRESSED_R5G5B5A1,      // 16 bpp (1 bit alpha)
	UNCOMPRESSED_R4G4B4A4,      // 16 bpp (4 bit alpha)
	UNCOMPRESSED_R8G8B8A8,      // 32 bpp
	UNCOMPRESSED_R32,           // 32 bpp (1 channel - float)
	UNCOMPRESSED_R32G32B32,     // 32*3 bpp (3 channels - float)
	UNCOMPRESSED_R32G32B32A32,  // 32*4 bpp (4 channels - float)
	UNCOMPRESSED_R16,           // 16 bpp (1 channel - half float)
	UNCOMPRESSED_R16G16B16,     // 16*3 bpp (3 channels - half float)
	UNCOMPRESSED_R16G16B16A16,  // 16*4 bpp (4 channels - half float)
	COMPRESSED_DXT1_RGB,        // 4 bpp (no alpha)
	COMPRESSED_DXT1_RGBA,       // 4 bpp (1 bit alpha)
	COMPRESSED_DXT3_RGBA,       // 8 bpp
	COMPRESSED_DXT5_RGBA,       // 8 bpp
	COMPRESSED_ETC1_RGB,        // 4 bpp
	COMPRESSED_ETC2_RGB,        // 4 bpp
	COMPRESSED_ETC2_EAC_RGBA,   // 8 bpp
	COMPRESSED_PVRT_RGB,        // 4 bpp
	COMPRESSED_PVRT_RGBA,       // 4 bpp
	COMPRESSED_ASTC_4X4_RGBA,   // 8 bpp
	COMPRESSED_ASTC_8X8_RGBA,   // 2 bpp
}

$assert((uint)PixelFormat.UNCOMPRESSED_GRAYSCALE == 1);

// Texture parameters: filter mode
// NOTE 1: Filtering considers mipmaps if available in the texture
// NOTE 2: Filter is accordingly set for minification and magnification
enum TextureFilter : uint {
	POINT,                   // No filter, just pixel approximation
	BILINEAR,                // Linear filtering
	TRILINEAR,               // Trilinear filtering (linear with mipmaps)
	ANISOTROPIC_4X,          // Anisotropic filtering 4x
	ANISOTROPIC_8X,          // Anisotropic filtering 8x
	ANISOTROPIC_16X,         // Anisotropic filtering 16x
}

$assert((uint)TextureFilter.POINT == 0);

// Texture parameters: wrap mode
enum TextureWrap : uint {
	REPEAT,                // Repeats texture in tiled mode
	CLAMP,                     // Clamps texture to edge pixel in tiled mode
	MIRROR_REPEAT,             // Mirrors and repeats the texture in tiled mode
	MIRROR_CLAMP               // Mirrors and clamps to border the texture in tiled mode
}

$assert((uint)TextureWrap.REPEAT == 0);

// Cubemap layouts
enum CubemapLayout : uint {
	AUTO_DETECT,             // Automatically detect layout type
	LINE_VERTICAL,           // Layout is defined by a vertical line with faces
	LINE_HORIZONTAL,         // Layout is defined by a horizontal line with faces
	CROSS_THREE_BY_FOUR,     // Layout is defined by a 3x4 cross with cubemap faces
	CROSS_FOUR_BY_THREE,     // Layout is defined by a 4x3 cross with cubemap faces
	PANORAMA                 // Layout is defined by a panorama image (equirrectangular map)
}

$assert((uint)CubemapLayout.AUTO_DETECT == 0);

// Font type, defines generation method
enum FontType : uint {
	DEFAULT,               // Default font generation, anti-aliased
	BITMAP,                    // Bitmap font generation, no anti-aliasing
	SDF                        // SDF font generation, requires external shader
}

$assert((uint)FontType.DEFAULT == 0);

// Color blending modes (pre-defined)
enum BlendMode : uint {
	ALPHA,                    // Blend textures considering alpha (default)
	ADDITIVE,                 // Blend textures adding colors
	MULTIPLIED,               // Blend textures multiplying colors
	ADD_COLORS,               // Blend textures adding colors (alternative)
	SUBTRACT_COLORS,          // Blend textures subtracting colors (alternative)
	ALPHA_PREMULTIPLY,        // Blend premultiplied textures considering alpha
	CUSTOM,                   // Blend textures using custom src/dst factors (use rlSetBlendFactors())
	CUSTOM_SEPARATE           // Blend textures using custom rgb/alpha separate src/dst factors (use rlSetBlendFactorsSeparate())
}

$assert((uint)BlendMode.ALPHA == 0);

// Gesture
// NOTE: Provided as bit-wise flags to enable only desired gestures
distinct Gesture = uint;
const Gesture GESTURE_NONE        = 0;        // No gesture
const Gesture GESTURE_TAP         = 1;        // Tap gesture
const Gesture GESTURE_DOUBLETAP   = 2;        // Double tap gesture
const Gesture GESTURE_HOLD        = 4;        // Hold gesture
const Gesture GESTURE_DRAG        = 8;        // Drag gesture
const Gesture GESTURE_SWIPE_RIGHT = 16;       // Swipe right gesture
const Gesture GESTURE_SWIPE_LEFT  = 32;       // Swipe left gesture
const Gesture GESTURE_SWIPE_UP    = 64;       // Swipe up gesture
const Gesture GESTURE_SWIPE_DOWN  = 128;      // Swipe down gesture
const Gesture GESTURE_PINCH_IN    = 256;      // Pinch in gesture
const Gesture GESTURE_PINCH_OUT   = 512;      // Pinch out gesture

// Camera system modes
enum CameraMode : uint {
	CUSTOM,                  // Custom camera
	FREE,                    // Free camera
	ORBITAL,                 // Orbital camera
	FIRST_PERSON,            // First person camera
	THIRD_PERSON             // Third person camera
}

$assert((uint)CameraMode.CUSTOM == 0);

// Camera projection
enum CameraProjection : uint {
	PERSPECTIVE,             // Perspective projection
	ORTHOGRAPHIC,            // Orthographic projection
}

$assert((uint)CameraProjection.PERSPECTIVE == 0);

// N-patch layout
enum NPatchLayout {
	NINE_PATCH,              // Npatch layout: 3x3 tiles
	THREE_PATCH_VERTICAL,    // Npatch layout: 1x3 tiles
	THREE_PATCH_HORIZONTAL   // Npatch layout: 3x1 tiles
}

$assert((int)NPatchLayout.NINE_PATCH == 0);

// Callbacks to hook some internal functions
// WARNING: These callbacks are intended for advance users
def LoadFileDataCallback = fn ZString(ZString file_name, int* data_size);          // FileIO: Load binary data
def SaveFileDataCallback = fn bool(ZString file_name, void* data, uint data_size); // FileIO: Save binary data
def LoadFileTextCallback = fn ZString(ZString file_name);                          // FileIO: Load text data
def SaveFileTextCallback = fn bool(ZString file_name, ZString text);               // FileIO: Save text data

//------------------------------------------------------------------------------------
// Global Variables Definition
//------------------------------------------------------------------------------------
// It's lonely here...

//------------------------------------------------------------------------------------
// Window and Graphics Device Functions (Module: core)
//------------------------------------------------------------------------------------

// Window-related functions
//------------------------------------------------------------------------------------
// Initialize window and OpenGL context
fn void init_window(int width, int height, ZString title) @extern("InitWindow");
// Close window and unload OpenGL context
fn void close_window() @extern("CloseWindow");
// Check if application should close (KEY_ESCAPE pressed or windows close icon clicked)
fn bool window_should_close() @extern("WindowShouldClose");
// Check if window has been initialized successfully
fn bool is_window_ready() @extern("IsWindowReady");
// Check if window is currently fullscreen
fn bool is_window_fullscreen() @extern("IsWindowFullscreen");
// Check if window is currently hidden (only PLATFORM_DESKTOP)
fn bool is_window_hidden() @extern("IsWindowHidden");
// Check if window is currently minimized (only PLATFORM_DESKTOP)
fn bool is_window_minimized() @extern("IsWindowMinimized");
// Check if window is currently maximized (only PLATFORM_DESKTOP)
fn bool is_window_maximized() @extern("IsWindowMaximized");
// Check if window is currently focused (only PLATFORM_DESKTOP)
fn bool is_window_focused() @extern("IsWindowFocused");
// Check if window has been resized last frame
fn bool is_window_resized() @extern("IsWindowResized");
// Check if one specific window flag is enabled
fn bool is_window_state(ConfigFlags flag) @extern("IsWindowState");
// Set window configuration state using flags (only PLATFORM_DESKTOP)
fn void set_window_state(ConfigFlags flags) @extern("SetWindowState");
// Clear window configuration state flags
fn void clear_window_state(ConfigFlags flags) @extern("ClearWindowState");
// Toggle window state: fullscreen/windowed (only PLATFORM_DESKTOP)
fn void toggle_fullscreen() @extern("ToggleFullscreen");
// Toggle window state: borderless windowed (only PLATFORM_DESKTOP)
fn void toggle_borderless_windowed() @extern("ToggleBorderlessWindowed");
// Set window state: maximized, if resizable (only PLATFORM_DESKTOP)
fn void maximize_window() @extern("MaximizeWindow");
// Set window state: minimized, if resizable (only PLATFORM_DESKTOP)
fn void minimize_window() @extern("MinimizeWindow");
// Set window state: not minimized/maximized (only PLATFORM_DESKTOP)
fn void restore_window() @extern("RestoreWindow");
// Set icon for window (single image, RGBA 32bit, only PLATFORM_DESKTOP)
fn void set_window_icon(Image image) @extern("SetWindowIcon");
// Set icon for window (multiple images, RGBA 32bit, only PLATFORM_DESKTOP)
fn void set_window_icons(Image* images, int count) @extern("SetWindowIcons");
// Set title for window (only PLATFORM_DESKTOP and PLATFORM_WEB)
fn void set_window_title(ZString title) @extern("SetWindowTitle");
// Set window position on screen (only PLATFORM_DESKTOP)
fn void set_window_position(int x, int y) @extern("SetWindowPosition");
// Set monitor for the current window
fn void set_window_monitor(int monitor) @extern("SetWindowMonitor");
// Set window minimum dimensions (for FLAG_WINDOW_RESIZABLE)
fn void set_window_min_size(int width, int height) @extern("SetWindowMinSize");
// Set window maximum dimensions (for FLAG_WINDOW_RESIZABLE)
fn void set_window_max_size(int width, int height) @extern("SetWindowMaxSize");
// Set window dimensions
fn void set_window_size(int width, int height) @extern("SetWindowSize");
// Set window opacity [0.0f..1.0f] (only PLATFORM_DESKTOP)
fn void set_window_opacity(float opacity) @extern("SetWindowOpacity");
// Set window focused (only PLATFORM_DESKTOP)
fn void set_window_focused() @extern("SetWindowFocused");
// Get native window handle
fn void* get_window_handle() @extern("GetWindowHandle");
// Get current screen width
fn int get_screen_width() @extern("GetScreenWidth");
// Get current screen height
fn int get_screen_height() @extern("GetScreenHeight");
// Get current render width (it considers HiDPI)
fn int get_render_width() @extern("GetRenderWidth");
// Get current render height (it considers HiDPI)
fn int get_render_height() @extern("GetRenderHeight");
// Get number of connected monitors
fn int get_monitor_count() @extern("GetMonitorCount");
// Get current connected monitor
fn int get_current_monitor() @extern("GetCurrentMonitor");
// Get specified monitor position
fn Vector2 get_monitor_position(int monitor) @extern("GetMonitorPosition");
// Get specified monitor width (current video mode used by monitor)
fn int get_monitor_width(int monitor) @extern("GetMonitorWidth");
// Get specified monitor height (current video mode used by monitor)
fn int get_monitor_height(int monitor) @extern("GetMonitorHeight");
// Get specified monitor physical width in millimetres
fn int get_monitor_physical_width(int monitor) @extern("GetMonitorPhysicalWidth");
// Get specified monitor physical height in millimetres
fn int get_monitor_physical_height(int monitor) @extern("GetMonitorPhysicalHeight");
// Get specified monitor refresh rate
fn int get_monitor_refresh_rate(int monitor) @extern("GetMonitorRefreshRate");
// Get window position XY on monitor
fn Vector2 get_window_position() @extern("GetWindowPosition");
// Get window scale DPI factor
fn Vector2 get_window_scale_dpi() @extern("GetWindowScaleDPI");
// Get the human-readable, UTF-8 encoded name of the specified monitor
fn ZString get_monitor_name(int monitor) @extern("GetMonitorName");
// Set clipboard text content
fn void set_clipboard_text(ZString text) @extern("SetClipboardText");
// Get clipboard text content
fn ZString get_clipboard_text() @extern("GetClipboardText");
// Enable waiting for events on EndDrawing(), no automatic event polling
fn void enable_event_waiting() @extern("EnableEventWaiting");
// Disable waiting for events on EndDrawing(), automatic events polling
fn void disable_event_waiting() @extern("DisableEventWaiting");

// Cursor-related functions
//------------------------------------------------------------------------------------
// Shows cursor
fn void show_cursor() @extern("ShowCursor");
// Hides cursor
fn void hide_cursor() @extern("HideCursor");
// Check if cursor is not visible
fn bool is_cursor_hidden() @extern("IsCursorHidden");
// Enables cursor (unlock cursor)
fn void enable_cursor() @extern("EnableCursor");
// Disables cursor (lock cursor)
fn void disable_cursor() @extern("DisableCursor");
// Check if cursor is on the screen
fn bool is_cursor_on_screen() @extern("IsCursorOnScreen");

// Drawing-related functions
//------------------------------------------------------------------------------------
// Set background color (framebuffer clear color)
fn void clear_background(Color color) @extern("ClearBackground");
// Setup canvas (framebuffer) to start drawing
fn void begin_drawing() @extern("BeginDrawing");
// End canvas drawing and swap buffers (double buffering)
fn void end_drawing() @extern("EndDrawing");
// Begin 2D mode with custom camera (2D)
fn void begin_mode2_d(Camera2D camera) @extern("BeginMode2D");
// Ends 2D mode with custom camera
fn void end_mode2_d() @extern("EndMode2D");
// Begin 3D mode with custom camera (3D)
fn void begin_mode3_d(Camera3D camera) @extern("BeginMode3D");
// Ends 3D mode and returns to default 2D orthographic mode
fn void end_mode3_d() @extern("EndMode3D");
// Begin drawing to render texture
fn void begin_texture_mode(RenderTexture2D target) @extern("BeginTextureMode");
// Ends drawing to render texture
fn void end_texture_mode() @extern("EndTextureMode");
// Begin custom shader drawing
fn void begin_shader_mode(Shader shader) @extern("BeginShaderMode");
// End custom shader drawing (use default shader)
fn void end_shader_mode() @extern("EndShaderMode");
// Begin blending mode (alpha, additive, multiplied, subtract, custom)
fn void begin_blend_mode(int mode) @extern("BeginBlendMode");
// End blending mode (reset to default: alpha blending)
fn void end_blend_mode() @extern("EndBlendMode");
// Begin scissor mode (define screen area for following drawing)
fn void begin_scissor_mode(int x, int y, int width, int height) @extern("BeginScissorMode");
// End scissor mode
fn void end_scissor_mode() @extern("EndScissorMode");
// Begin stereo rendering (requires VR simulator)
fn void begin_vr_stereo_mode(VrStereoConfig config) @extern("BeginVrStereoMode");
// End stereo rendering (requires VR simulator)
fn void end_vr_stereo_mode() @extern("EndVrStereoMode");

// VR stereo config functions for VR simulator
//------------------------------------------------------------------------------------
// Load VR stereo config for VR simulator device parameters
fn VrStereoConfig load_vr_stereo_config(VrDeviceInfo device) @extern("LoadVrStereoConfig");
// Unload VR stereo config
fn void unload_vr_stereo_config(VrStereoConfig config) @extern("UnloadVrStereoConfig");

// Shader management functions
// NOTE: Shader functionality is not available on OpenGL 1.1
//------------------------------------------------------------------------------------
// Load shader from files and bind default locations
fn Shader load_shader(ZString vs_file_name, ZString fs_file_name) @extern("LoadShader");
// Load shader from code strings and bind default locations
fn Shader load_shader_from_memory(ZString vs_code, ZString fs_code) @extern("LoadShaderFromMemory");
// Check if a shader is ready
fn bool is_shader_ready(Shader shader) @extern("IsShaderReady");
// Get shader uniform location
fn int get_shader_location(Shader shader, ZString uniform_name) @extern("GetShaderLocation");
// Get shader attribute location
fn int get_shader_location_attrib(Shader shader, ZString attrib_name) @extern("GetShaderLocationAttrib");
// Set shader uniform value
fn void set_shader_value(Shader shader, int loc_index, void* value, int uniform_type) @extern("SetShaderValue");
// Set shader uniform value vector
fn void set_shader_value_v(Shader shader, int locIndex, void* value, int uniform_type, int count) @extern("SetShaderValueV");
// Set shader uniform value (matrix 4x4)
fn void set_shader_value_matrix(Shader shader, int locIndex, Matrix mat) @extern("SetShaderValueMatrix");
// Set shader uniform value for texture (sampler2d)
fn void set_shader_value_texture(Shader shader, int locIndex, Texture2D texture) @extern("SetShaderValueTexture");
// Unload shader from GPU memory (VRAM)
fn void unload_shader(Shader shader) @extern("UnloadShader");

// Screen-space-related functions
//------------------------------------------------------------------------------------
// Get a ray trace from mouse position
fn Ray get_mouse_ray(Vector2 mousePosition, Camera camera) @extern("GetMouseRay");
// Get camera transform matrix (view matrix)
fn Matrix get_camera_matrix(Camera camera) @extern("GetCameraMatrix");
// Get camera 2d transform matrix
fn Matrix get_camera_matrix2_d(Camera2D camera) @extern("GetCameraMatrix2D");
// Get the screen space position for a 3d world space position
fn Vector2 get_world_to_screen(Vector3 position, Camera camera) @extern("GetWorldToScreen");
// Get the world space position for a 2d camera screen space position
fn Vector2 get_screen_to_world2_d(Vector2 position, Camera2D camera) @extern("GetScreenToWorld2D");
// Get size position for a 3d world space position
fn Vector2 get_world_to_screen_ex(Vector3 position, Camera camera, int width, int height) @extern("GetWorldToScreenEx");
// Get the screen space position for a 2d camera world space position
fn Vector2 get_world_to_screen2_d(Vector2 position, Camera2D camera) @extern("GetWorldToScreen2D");

// Timing-related functions
//------------------------------------------------------------------------------------
// Set target FPS (maximum)
fn void set_target_fps(int fps) @extern("SetTargetFPS");
// Get time in seconds for last frame drawn (delta time)
fn float get_frame_time() @extern("GetFrameTime");
// Get elapsed time in seconds since InitWindow()
fn double get_time() @extern("GetTime");
// Get current FPS
fn int get_fps() @extern("GetFPS");

// Custom frame control functions
// NOTE: Those functions are intended for advance users that want full control over the frame processing
// By default EndDrawing() does this job: draws everything + SwapScreenBuffer() + manage frame timing + PollInputEvents()
// To avoid that behaviour and control frame processes manually, enable in config.h: SUPPORT_CUSTOM_FRAME_CONTROL
//------------------------------------------------------------------------------------
// Swap back buffer with front buffer (screen drawing)
fn void swap_screen_buffer() @extern("SwapScreenBuffer");
// Register all input events
fn void poll_input_events() @extern("PollInputEvents");
// Wait for some time (halt program execution)
fn void wait_time(double seconds) @extern("WaitTime");

// Random values generation functions
//------------------------------------------------------------------------------------
// Set the seed for the random number generator
fn void set_random_seed(uint seed) @extern("SetRandomSeed");
// Get a random value between min and max (both included)
fn int get_random_value(int min, int max) @extern("GetRandomValue");
// Load random values sequence, no values repeated
fn int* load_random_sequence(uint count, int min, int max) @extern("LoadRandomSequence");
// Unload random values sequence
fn void unload_random_sequence(int* sequence) @extern("UnloadRandomSequence");

// Misc. functions
//------------------------------------------------------------------------------------
// Takes a screenshot of current screen (filename extension defines format)
fn void take_screenshot(ZString file_name) @extern("TakeScreenshot");
// Setup init configuration flags (view FLAGS)
fn void set_config_flags(uint flags) @extern("SetConfigFlags");
// Open URL with default system browser (if available)
fn void open_url(ZString url) @extern("OpenURL");

// NOTE: Following functions implemented in module [utils]
//------------------------------------------------------------------
// Show trace log messages (LOG_DEBUG, LOG_INFO, LOG_WARNING, LOG_ERROR...)
fn void trace_log(TraceLogLevel logLevel, ZString text, ...) @extern("TraceLog");
// Set the current threshold (minimum) log level
fn void set_trace_log_level(TraceLogLevel logLevel) @extern("SetTraceLogLevel");
// Internal memory allocator
fn void* mem_alloc(uint size) @extern("MemAlloc");
// Internal memory reallocator
fn void* mem_realloc(void* ptr, uint size) @extern("MemRealloc");
// Internal memory free
fn void mem_free(void* ptr) @extern("MemFree");

// Set custom callbacks
// WARNING: Callbacks setup is intended for advance users
//------------------------------------------------------------------------------------
// Set custom file binary data loader
fn void set_load_file_data_callback(LoadFileDataCallback callback) @extern("SetLoadFileDataCallback");
// Set custom file binary data saver
fn void set_save_file_data_callback(SaveFileDataCallback callback) @extern("SetSaveFileDataCallback");
// Set custom file text data loader
fn void set_load_file_text_callback(LoadFileTextCallback callback) @extern("SetLoadFileTextCallback");
// Set custom file text data saver
fn void set_save_file_text_callback(SaveFileTextCallback callback) @extern("SetSaveFileTextCallback");

// Files management functions
//------------------------------------------------------------------------------------
// Load file data as byte array (read)
fn char* load_file_data(ZString file_name, int* data_size) @extern("LoadFileData");
// Unload file data allocated by LoadFileData()
fn void unload_file_data(ZString data) @extern("UnloadFileData");
// Save data to file from byte array (write), returns true on success
fn bool save_file_data(ZString file_name, void* data, int data_size) @extern("SaveFileData");
// Export data to code (.h), returns true on success
fn bool export_data_as_code(ZString data, int data_size, ZString file_name) @extern("ExportDataAsCode");
// Load text data from file (read), returns a '\0' terminated string
fn char* load_file_text(ZString file_name) @extern("LoadFileText");
// Unload file text data allocated by LoadFileText()
fn void unload_file_text(ZString text) @extern("UnloadFileText");
// Save text data to file (write), string must be '\0' terminated, returns true on success
fn bool save_file_text(ZString file_name, ZString text) @extern("SaveFileText");
//------------------------------------------------------------------

// File system functions
//------------------------------------------------------------------------------------
// Check if file exists
fn bool file_exists(ZString file_name) @extern("FileExists");
// Check if a directory path exists
fn bool directory_exists(ZString dir_path) @extern("DirectoryExists");
// Check file extension (including point: .png, .wav)
fn bool is_file_extension(ZString file_name, ZString ext) @extern("IsFileExtension");
// Get file length in bytes (NOTE: GetFileSize() conflicts with windows.h)
fn int get_file_length(ZString file_name) @extern("GetFileLength");
// Get pointer to extension for a filename string (includes dot: '.png')
fn ZString get_file_extension(ZString file_name) @extern("GetFileExtension");
// Get pointer to filename for a path string
fn ZString get_file_name(ZString file_path) @extern("GetFileName");
// Get filename string without extension (uses static string)
fn ZString get_file_name_without_ext(ZString file_path) @extern("GetFileNameWithoutExt");
// Get full path for a given fileName with path (uses static string)
fn ZString get_directory_path(ZString file_path) @extern("GetDirectoryPath");
// Get previous directory path for a given path (uses static string)
fn ZString get_prev_directory_path(ZString dir_path) @extern("GetPrevDirectoryPath");
// Get current working directory (uses static string)
fn ZString get_working_directory() @extern("GetWorkingDirectory");
// Get the directory of the running application (uses static string)
fn ZString get_application_directory() @extern("GetApplicationDirectory");
// Change working directory, return true on success
fn bool change_directory(ZString dir) @extern("ChangeDirectory");
// Check if a given path is a file or a directory
fn bool is_path_file(ZString path) @extern("IsPathFile");
// Load directory filepaths
fn FilePathList load_directory_files(ZString  dir_path) @extern("LoadDirectoryFiles");
// Load directory filepaths with extension filtering and recursive directory scan
fn FilePathList load_directory_files_ex(ZString base_path, ZString filter, bool scan_subdirs) @extern("LoadDirectoryFilesEx");
// Unload filepaths
fn void unload_directory_files(FilePathList files) @extern("UnloadDirectoryFiles");
// Check if a file has been dropped into window
fn bool is_file_dropped() @extern("IsFileDropped");
// Load dropped filepaths
fn FilePathList load_dropped_files() @extern("LoadDroppedFiles");
// Unload dropped filepaths
fn void unload_dropped_files(FilePathList files) @extern("UnloadDroppedFiles");
// Get file modification time (last write time)
fn long get_file_mod_time(ZString file_name) @extern("GetFileModTime");

// Compression/Encoding functionality
//------------------------------------------------------------------------------------
// Compress data (DEFLATE algorithm), memory must be MemFree()
fn char* compress_data(ZString data, int dataSize, int *comp_data_size) @extern("CompressData");
// Decompress data (DEFLATE algorithm), memory must be MemFree()
fn char* decompress_data(ZString comp_data, int comp_data_size, int *data_size) @extern("DecompressData");
// Encode data to Base64 string, memory must be MemFree()
fn char* encode_data_base64(ZString data, int data_size, int *outputSize) @extern("EncodeDataBase64");
// Decode Base64 string data, memory must be MemFree()
fn char* decode_data_base64(ZString data, int *output_size) @extern("DecodeDataBase64");

// Automation events functionality
//------------------------------------------------------------------------------------
// Load automation events list from file, NULL for empty list, capacity = MAX_AUTOMATION_EVENTS
fn AutomationEventList load_automation_event_list(ZString file_name) @extern("LoadAutomationEventList");
// Unload automation events list from file
fn void unload_automation_event_list(AutomationEventList* list) @extern("UnloadAutomationEventList");
// Export automation events list as text file
fn bool export_automation_event_list(AutomationEventList list, ZString file_name) @extern("ExportAutomationEventList");
// Set automation event list to record to
fn void set_automation_event_list(AutomationEventList* list) @extern("SetAutomationEventList");
// Set automation event internal base frame to start recording
fn void set_automation_event_base_frame(int frame) @extern("SetAutomationEventBaseFrame");
// Start recording automation events (AutomationEventList must be set)
fn void start_automation_event_recording() @extern("StartAutomationEventRecording");
// Stop recording automation events
fn void stop_automation_event_recording() @extern("StopAutomationEventRecording");
// Play a recorded automation event
fn void play_automation_event(AutomationEvent event) @extern("PlayAutomationEvent");

//------------------------------------------------------------------------------------
// Input Handling Functions (Module: core)
//------------------------------------------------------------------------------------

// Input-related functions: keyboard
//------------------------------------------------------------------------------------
// Check if a key has been pressed once
fn bool is_key_pressed(KeyboardKey key) @extern("IsKeyPressed");
// Check if a key has been pressed again (Only PLATFORM_DESKTOP)
fn bool is_key_pressed_repeat(KeyboardKey key) @extern("IsKeyPressedRepeat");
// Check if a key is being pressed
fn bool is_key_down(KeyboardKey key) @extern("IsKeyDown");
// Check if a key has been released once
fn bool is_key_released(KeyboardKey key) @extern("IsKeyReleased");
// Check if a key is NOT being pressed
fn bool is_key_up(KeyboardKey key) @extern("IsKeyUp");
// Get key pressed (keycode), call it multiple times for keys queued, returns 0 when the queue is empty
fn KeyboardKey get_key_pressed() @extern("GetKeyPressed");
// Get char pressed (unicode), call it multiple times for chars queued, returns 0 when the queue is empty
fn KeyboardKey get_char_pressed() @extern("GetCharPressed");
// Set a custom key to exit program (default is ESC)
fn void set_exit_key(KeyboardKey key) @extern("SetExitKey");

// Input-related functions: gamepads
//------------------------------------------------------------------------------------
// Check if a gamepad is available
fn bool is_gamepad_available(int gamepad) @extern("IsGamepadAvailable");
// Get gamepad internal name id
fn ZString get_gamepad_name(int gamepad) @extern("GetGamepadName");
// Check if a gamepad button has been pressed once
fn bool is_gamepad_button_pressed(int gamepad, GamepadButton button) @extern("IsGamepadButtonPressed");
// Check if a gamepad button is being pressed
fn bool is_gamepad_button_down(int gamepad, GamepadButton button) @extern("IsGamepadButtonDown");
// Check if a gamepad button has been released once
fn bool is_gamepad_button_released(int gamepad, GamepadButton button) @extern("IsGamepadButtonReleased");
// Check if a gamepad button is NOT being pressed
fn bool is_gamepad_button_up(int gamepad, GamepadButton button) @extern("IsGamepadButtonUp");
// Get the last gamepad button pressed
fn int get_gamepad_button_pressed() @extern("GetGamepadButtonPressed");
// Get gamepad axis count for a gamepad
fn int get_gamepad_axis_count(int gamepad) @extern("GetGamepadAxisCount");
// Get axis movement value for a gamepad axis
fn float get_gamepad_axis_movement(int gamepad, int axis) @extern("GetGamepadAxisMovement");
// Set internal gamepad mappings (SDL_GameControllerDB)
fn int set_gamepad_mappings(ZString mappings) @extern("SetGamepadMappings");

// Input-related functions: mouse
//------------------------------------------------------------------------------------
// Check if a mouse button has been pressed once
fn bool is_mouse_button_pressed(MouseButton button) @extern("IsMouseButtonPressed");
// Check if a mouse button is being pressed
fn bool is_mouse_button_down(MouseButton button) @extern("IsMouseButtonDown");
// Check if a mouse button has been released once
fn bool is_mouse_button_released(MouseButton button) @extern("IsMouseButtonReleased");
// Check if a mouse button is NOT being pressed
fn bool is_mouse_button_up(MouseButton button) @extern("IsMouseButtonUp");
// Get mouse position X
fn int get_mouse_x() @extern("GetMouseX");
// Get mouse position Y
fn int get_mouse_y() @extern("GetMouseY");
// Get mouse position XY
fn Vector2 get_mouse_position() @extern("GetMousePosition");
// Get mouse delta between frames
fn Vector2 get_mouse_delta() @extern("GetMouseDelta");
// Set mouse position XY
fn void set_mouse_position(int x, int y) @extern("SetMousePosition");
// Set mouse offset
fn void set_mouse_offset(int offset_x, int offset_y) @extern("SetMouseOffset");
// Set mouse scaling
fn void set_mouse_scale(float scale_x, float scale_y) @extern("SetMouseScale");
// Get mouse wheel movement for X or Y, whichever is larger
fn float get_mouse_wheel_move() @extern("GetMouseWheelMove");
// Get mouse wheel movement for both X and Y
fn Vector2 get_mouse_wheel_move_v() @extern("GetMouseWheelMoveV");
// Set mouse cursor
fn void set_mouse_cursor(int cursor) @extern("SetMouseCursor");

// Input-related functions: touch
//------------------------------------------------------------------------------------
// Get touch position X for touch point 0 (relative to screen size)
fn int get_touch_x() @extern("GetTouchX");
// Get touch position Y for touch point 0 (relative to screen size)
fn int get_touch_y() @extern("GetTouchY");
// Get touch position XY for a touch point index (relative to screen size)
fn Vector2 get_touch_position(int index) @extern("GetTouchPosition");
// Get touch point identifier for given index
fn int get_touch_point_id(int index) @extern("GetTouchPointId");
// Get number of touch points
fn int get_touch_point_count() @extern("GetTouchPointCount");

//------------------------------------------------------------------------------------
// Gestures and Touch Handling Functions (Module: rgestures)
//------------------------------------------------------------------------------------
// Enable a set of gestures using flags
fn void set_gestures_enabled(Gesture flags) @extern("SetGesturesEnabled");
// Check if a gesture have been detected
fn bool is_gesture_detected(Gesture gesture) @extern("IsGestureDetected");
// Get latest detected gesture
fn int get_gesture_detected() @extern("GetGestureDetected");
// Get gesture hold time in milliseconds
fn float get_gesture_hold_duration() @extern("GetGestureHoldDuration");
// Get gesture drag vector
fn Vector2 get_gesture_drag_vector() @extern("GetGestureDragVector");
// Get gesture drag angle
fn float get_gesture_drag_angle() @extern("GetGestureDragAngle");
// Get gesture pinch delta
fn Vector2 get_gesture_pinch_vector() @extern("GetGesturePinchVector");
// Get gesture pinch angle
fn float get_gesture_pinch_angle() @extern("GetGesturePinchAngle");

//------------------------------------------------------------------------------------
// Camera System Functions (Module: rcamera)
//------------------------------------------------------------------------------------
// Update camera position for selected mode
fn void update_camera(Camera* camera, int mode) @extern("UpdateCamera");
// Update camera movement/rotation
fn void update_camera_pro(Camera* camera, Vector3 movement, Vector3 rotation, float zoom) @extern("UpdateCameraPro");

//------------------------------------------------------------------------------------
// Basic Shapes Drawing Functions (Module: shapes)
//------------------------------------------------------------------------------------
// Set texture and rectangle to be used on shapes drawing
// NOTE: It can be useful when using basic shapes and one single font,
// defining a font char white rectangle would allow drawing everything in a single draw call
//------------------------------------------------------------------------------------
// Set texture and rectangle to be used on shapes drawing
fn void set_shapes_texture(Texture2D texture, Rectangle source) @extern("SetShapesTexture");

// Basic shapes drawing functions
//------------------------------------------------------------------------------------
// Draw a pixel
fn void draw_pixel(int pos_x, int pos_y, Color color) @extern("DrawPixel");
// Draw a pixel (Vector version)
fn void draw_pixel_v(Vector2 position, Color color) @extern("DrawPixelV");
// Draw a line
fn void draw_line(int start_pos_x, int start_pos_y, int end_pos_x, int end_pos_y, Color color) @extern("DrawLine");
// Draw a line (using gl lines)
fn void draw_line_v(Vector2 start_pos, Vector2 end_pos, Color color) @extern("DrawLineV");
// Draw a line (using triangles/quads)
fn void draw_line_ex(Vector2 start_pos, Vector2 end_pos, float thick, Color color) @extern("DrawLineEx");
// Draw lines sequence (using gl lines)
fn void draw_line_strip(Vector2* points, int point_count, Color color) @extern("DrawLineStrip");
// Draw line segment cubic-bezier in-out interpolation
fn void draw_line_bezier(Vector2 start_pos, Vector2 end_pos, float thick, Color color) @extern("DrawLineBezier");
// Draw a color-filled circle
fn void draw_circle(int center_x, int center_y, float radius, Color color) @extern("DrawCircle");
// Draw a piece of a circle
fn void draw_circle_sector(Vector2 center, float radius, float start_angle, float end_angle, int segments, Color color) @extern("DrawCircleSector");
// Draw circle sector outline
fn void draw_circle_sector_lines(Vector2 center, float radius, float start_angle, float end_angle, int segments, Color color) @extern("DrawCircleSectorLines");
// Draw a gradient-filled circle
fn void draw_circle_gradient(int center_x, int center_y, float radius, Color color1, Color color2) @extern("DrawCircleGradient");
// Draw a color-filled circle (Vector version)
fn void draw_circle_v(Vector2 center, float radius, Color color) @extern("DrawCircleV");
// Draw circle outline
fn void draw_circle_lines(int center_x, int center_y, float radius, Color color) @extern("DrawCircleLines");
// Draw circle outline (Vector version)
fn void draw_circle_lines_v(Vector2 center, float radius, Color color) @extern("DrawCircleLinesV");
// Draw ellipse
fn void draw_ellipse(int center_x, int center_y, float radius_h, float radius_v, Color color) @extern("DrawEllipse");
// Draw ellipse outline
fn void draw_ellipse_lines(int center_x, int center_y, float radius_h, float radius_v, Color color) @extern("DrawEllipseLines");
// Draw ring
fn void draw_ring(Vector2 center, float inner_radius, float outer_radius, float start_angle, float end_angle, int segments, Color color) @extern("DrawRing");
// Draw ring outline
fn void draw_ring_lines(Vector2 center, float inner_radius, float outer_radius, float start_angle, float end_angle, int segments, Color color) @extern("DrawRingLines");
// Draw a color-filled rectangle
fn void draw_rectangle(int pos_x, int pos_y, int width, int height, Color color) @extern("DrawRectangle");
// Draw a color-filled rectangle (Vector version)
fn void draw_rectangle_v(Vector2 position, Vector2 size, Color color) @extern("DrawRectangleV");
// Draw a color-filled rectangle
fn void draw_rectangle_rec(Rectangle rec, Color color) @extern("DrawRectangleRec");
// Draw a color-filled rectangle with pro parameters
fn void draw_rectangle_pro(Rectangle rec, Vector2 origin, float rotation, Color color) @extern("DrawRectanglePro");
// Draw a vertical-gradient-filled rectangle
fn void draw_rectangle_gradient_v(int pos_x, int pos_y, int width, int height, Color color1, Color color2) @extern("DrawRectangleGradientV");
// Draw a horizontal-gradient-filled rectangle
fn void draw_rectangle_gradient_h(int pos_x, int pos_y, int width, int height, Color color1, Color color2) @extern("DrawRectangleGradientH");
// Draw a gradient-filled rectangle with custom vertex colors
fn void draw_rectangle_gradient_ex(Rectangle rec, Color col1, Color col2, Color col3, Color col4) @extern("DrawRectangleGradientEx");
// Draw rectangle outline
fn void draw_rectangle_lines(int pos_x, int pos_y, int width, int height, Color color) @extern("DrawRectangleLines");
// Draw rectangle outline with extended parameters
fn void draw_rectangle_lines_ex(Rectangle rec, float line_thick, Color color) @extern("DrawRectangleLinesEx");
// Draw rectangle with rounded edges
fn void draw_rectangle_rounded(Rectangle rec, float roundness, int segments, Color color) @extern("DrawRectangleRounded");
// Draw rectangle with rounded edges outline
fn void draw_rectangle_rounded_lines(Rectangle rec, float roundness, int segments, float line_thick, Color color) @extern("DrawRectangleRoundedLines");
// Draw a color-filled triangle (vertex in counter-clockwise order!)
fn void draw_triangle(Vector2 v1, Vector2 v2, Vector2 v3, Color color) @extern("DrawTriangle");
// Draw triangle outline (vertex in counter-clockwise order!)
fn void draw_triangle_lines(Vector2 v1, Vector2 v2, Vector2 v3, Color color) @extern("DrawTriangleLines");
// Draw a triangle fan defined by points (first vertex is the center)
fn void draw_triangle_fan(Vector2* points, int point_count, Color color) @extern("DrawTriangleFan");
// Draw a triangle strip defined by points
fn void draw_triangle_strip(Vector2* points, int point_count, Color color) @extern("DrawTriangleStrip");
// Draw a regular polygon (Vector version)
fn void draw_poly(Vector2 center, int sides, float radius, float rotation, Color color) @extern("DrawPoly");
// Draw a polygon outline of n sides
fn void draw_poly_lines(Vector2 center, int sides, float radius, float rotation, Color color) @extern("DrawPolyLines");
// Draw a polygon outline of n sides with extended parameters
fn void draw_poly_lines_ex(Vector2 center, int sides, float radius, float rotation, float line_thick, Color color) @extern("DrawPolyLinesEx");

// Splines drawing functions
//------------------------------------------------------------------------------------
// Draw spline: Linear, minimum 2 points
fn void draw_spline_linear(Vector2* points, int point_count, float thick, Color color) @extern("DrawSplineLinear");
// Draw spline: B-Spline, minimum 4 points
fn void draw_spline_basis(Vector2* points, int point_count, float thick, Color color) @extern("DrawSplineBasis");
// Draw spline: Catmull-Rom, minimum 4 points
fn void draw_spline_catmull_rom(Vector2* points, int point_count, float thick, Color color) @extern("DrawSplineCatmullRom");
// Draw spline: Quadratic Bezier, minimum 3 points (1 control point): [p1, c2, p3, c4...]
fn void draw_spline_bezier_quadratic(Vector2* points, int point_count, float thick, Color color) @extern("DrawSplineBezierQuadratic");
// Draw spline: Cubic Bezier, minimum 4 points (2 control points): [p1, c2, c3, p4, c5, c6...]
fn void draw_spline_bezier_cubic(Vector2* points, int point_count, float thick, Color color) @extern("DrawSplineBezierCubic");
// Draw spline segment: Linear, 2 points
fn void draw_spline_segment_linear(Vector2 p1, Vector2 p2, float thick, Color color) @extern("DrawSplineSegmentLinear");
// Draw spline segment: B-Spline, 4 points
fn void draw_spline_segment_basis(Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, float thick, Color color) @extern("DrawSplineSegmentBasis");
// Draw spline segment: Catmull-Rom, 4 points
fn void draw_spline_segment_catmull_rom(Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, float thick, Color color) @extern("DrawSplineSegmentCatmullRom");
// Draw spline segment: Quadratic Bezier, 2 points, 1 control point
fn void draw_spline_segment_bezier_quadratic(Vector2 p1, Vector2 c2, Vector2 p3, float thick, Color color) @extern("DrawSplineSegmentBezierQuadratic");
// Draw spline segment: Cubic Bezier, 2 points, 2 control points
fn void draw_spline_segment_bezier_cubic(Vector2 p1, Vector2 c2, Vector2 c3, Vector2 p4, float thick, Color color) @extern("DrawSplineSegmentBezierCubic");

// Spline segment point evaluation functions, for a given t [0.0f .. 1.0f]
//------------------------------------------------------------------------------------
// Get (evaluate) spline point: Linear
fn Vector2 get_spline_point_linear(Vector2 start_pos, Vector2 end_pos, float t) @extern("GetSplinePointLinear");
// Get (evaluate) spline point: B-Spline
fn Vector2 get_spline_point_basis(Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, float t) @extern("GetSplinePointBasis");
// Get (evaluate) spline point: Catmull-Rom
fn Vector2 get_spline_point_catmull_rom(Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, float t) @extern("GetSplinePointCatmullRom");
// Get (evaluate) spline point: Quadratic Bezier
fn Vector2 get_spline_point_bezier_quad(Vector2 p1, Vector2 c2, Vector2 p3, float t) @extern("GetSplinePointBezierQuad");
// Get (evaluate) spline point: Cubic Bezier
fn Vector2 get_spline_point_bezier_cubic(Vector2 p1, Vector2 c2, Vector2 c3, Vector2 p4, float t) @extern("GetSplinePointBezierCubic");

// Basic shapes collision detection functions
//------------------------------------------------------------------------------------
// Check collision between two rectangles
fn bool check_collision_recs(Rectangle rec1, Rectangle rec2) @extern("CheckCollisionRecs");
// Check collision between two circles
fn bool check_collision_circles(Vector2 center1, float radius1, Vector2 center2, float radius2) @extern("CheckCollisionCircles");
// Check collision between circle and rectangle
fn bool check_collision_circle_rec(Vector2 center, float radius, Rectangle rec) @extern("CheckCollisionCircleRec");
// Check if point is inside rectangle
fn bool check_collision_point_rec(Vector2 point, Rectangle rec) @extern("CheckCollisionPointRec");
// Check if point is inside circle
fn bool check_collision_point_circle(Vector2 point, Vector2 center, float radius) @extern("CheckCollisionPointCircle");
// Check if point is inside a triangle
fn bool check_collision_point_triangle(Vector2 point, Vector2 p1, Vector2 p2, Vector2 p3) @extern("CheckCollisionPointTriangle");
// Check if point is within a polygon described by array of vertices
fn bool check_collision_point_poly(Vector2 point, Vector2* points, int point_count) @extern("CheckCollisionPointPoly");
// Check the collision between two lines defined by two points each, returns collision point by reference
fn bool check_collision_lines(Vector2 start_pos1, Vector2 end_pos1, Vector2 start_pos2, Vector2 end_pos2, Vector2* collision_point) @extern("CheckCollisionLines");
// Check if point belongs to line created between two points [p1] and [p2] with defined margin in pixels [threshold]
fn bool check_collision_point_line(Vector2 point, Vector2 p1, Vector2 p2, int threshold) @extern("CheckCollisionPointLine");
// Get collision rectangle for two rectangles collision
fn Rectangle get_collision_rec(Rectangle rec1, Rectangle rec2) @extern("GetCollisionRec");

//------------------------------------------------------------------------------------
// Texture Loading and Drawing Functions (Module: textures)
//------------------------------------------------------------------------------------

// Image loading functions
// NOTE: These functions do not require GPU access
//------------------------------------------------------------------------------------
// Load image from file into CPU memory (RAM)
fn Image load_image(ZString file_name) @extern("LoadImage");
// Load image from RAW file data
fn Image load_image_raw(ZString file_name, int width, int height, int format, int header_size) @extern("LoadImageRaw");
// Load image from SVG file data or string with specified size
fn Image load_image_svg(ZString file_name_or_string, int width, int height) @extern("LoadImageSvg");
// Load image sequence from file (frames appended to image.data)
fn Image load_image_anim(ZString file_name, int *frames) @extern("LoadImageAnim");
// Load image from memory buffer, fileType refers to extension: i.e. '.png'
fn Image load_image_from_memory(ZString file_type, ZString file_data, int data_size) @extern("LoadImageFromMemory");
// Load image from GPU texture data
fn Image load_image_from_texture(Texture2D texture) @extern("LoadImageFromTexture");
// Load image from screen buffer and (screenshot)
fn Image load_image_from_screen() @extern("LoadImageFromScreen");
// Check if an image is ready
fn bool is_image_ready(Image image) @extern("IsImageReady");
// Unload image from CPU memory (RAM)
fn void unload_image(Image image) @extern("UnloadImage");
// Export image data to file, returns true on success
fn bool export_image(Image image, ZString file_name) @extern("ExportImage");
// Export image to memory buffer
fn char* export_image_to_memory(Image image, ZString file_type, int *file_size) @extern("ExportImageToMemory");
// Export image as code file defining an array of bytes, returns true on success
fn bool export_image_as_code(Image image, ZString file_name) @extern("ExportImageAsCode");

// Image generation functions
//------------------------------------------------------------------------------------
// Generate image: plain color
fn Image gen_image_color(int width, int height, Color color) @extern("GenImageColor");
// Generate image: linear gradient, direction in degrees [0..360], 0=Vertical gradient
fn Image gen_image_gradient_linear(int width, int height, int direction, Color start, Color end) @extern("GenImageGradientLinear");
// Generate image: radial gradient
fn Image gen_image_gradient_radial(int width, int height, float density, Color inner, Color outer) @extern("GenImageGradientRadial");
// Generate image: square gradient
fn Image gen_image_gradient_square(int width, int height, float density, Color inner, Color outer) @extern("GenImageGradientSquare");
// Generate image: checked
fn Image gen_image_checked(int width, int height, int checks_x, int checks_y, Color col1, Color col2) @extern("GenImageChecked");
// Generate image: white noise
fn Image gen_image_white_noise(int width, int height, float factor) @extern("GenImageWhiteNoise");
// Generate image: perlin noise
fn Image gen_image_perlin_noise(int width, int height, int offset_x, int offset_y, float scale) @extern("GenImagePerlinNoise");
// Generate image: cellular algorithm, bigger tileSize means bigger cells
fn Image gen_image_cellular(int width, int height, int tile_size) @extern("GenImageCellular");
// Generate image: grayscale image from text data
fn Image gen_image_text(int width, int height, ZString text) @extern("GenImageText");

// Image manipulation functions
//------------------------------------------------------------------------------------
// Create an image duplicate (useful for transformations)
fn Image image_copy(Image image) @extern("ImageCopy");
// Create an image from another image piece
fn Image image_from_image(Image image, Rectangle rec) @extern("ImageFromImage");
// Create an image from text (default font)
fn Image image_text(ZString text, int font_size, Color color) @extern("ImageText");
// Create an image from text (custom sprite font)
fn Image image_text_ex(Font font, ZString text, float font_size, float spacing, Color tint) @extern("ImageTextEx");
// Convert image data to desired format
fn void image_format(Image* image, int new_format) @extern("ImageFormat");
// Convert image to POT (power-of-two)
fn void image_to_pot(Image* image, Color fill) @extern("ImageToPOT");
// Crop an image to a defined rectangle
fn void image_crop(Image* image, Rectangle crop) @extern("ImageCrop");
// Crop image depending on alpha value
fn void image_alpha_crop(Image* image, float threshold) @extern("ImageAlphaCrop");
// Clear alpha channel to desired color
fn void image_alpha_clear(Image* image, Color color, float threshold) @extern("ImageAlphaClear");
// Apply alpha mask to image
fn void image_alpha_mask(Image* image, Image alpha_mask) @extern("ImageAlphaMask");
// Premultiply alpha channel
fn void image_alpha_premultiply(Image* image) @extern("ImageAlphaPremultiply");
// Apply Gaussian blur using a box blur approximation
fn void image_blur_gaussian(Image* image, int blur_size) @extern("ImageBlurGaussian");
// Resize image (Bicubic scaling algorithm)
fn void image_resize(Image* image, int new_width, int new_height) @extern("ImageResize");
// Resize image (Nearest-Neighbor scaling algorithm)
fn void image_resize_nn(Image* image, int new_width,int new_height) @extern("ImageResizeNN");
// Resize canvas and fill with color
fn void image_resize_canvas(Image* image, int new_width, int new_height, int offset_x, int offset_y, Color fill) @extern("ImageResizeCanvas");
// Compute all mipmap levels for a provided image
fn void image_mipmaps(Image* image) @extern("ImageMipmaps");
// Dither image data to 16bpp or lower (Floyd-Steinberg dithering)
fn void image_dither(Image* image, int r_bpp, int g_bpp, int b_bpp, int a_bpp) @extern("ImageDither");
// Flip image vertically
fn void image_flip_vertical(Image* image) @extern("ImageFlipVertical");
// Flip image horizontally
fn void image_flip_horizontal(Image* image) @extern("ImageFlipHorizontal");
// Rotate image by input angle in degrees (-359 to 359)
fn void image_rotate(Image* image, int degrees) @extern("ImageRotate");
// Rotate image clockwise 90deg
fn void image_rotate_cw(Image* image) @extern("ImageRotateCW");
// Rotate image counter-clockwise 90deg
fn void image_rotate_ccw(Image* image) @extern("ImageRotateCCW");
// Modify image color: tint
fn void image_color_tint(Image* image, Color color) @extern("ImageColorTint");
// Modify image color: invert
fn void image_color_invert(Image* image) @extern("ImageColorInvert");
// Modify image color: grayscale
fn void image_color_grayscale(Image* image) @extern("ImageColorGrayscale");
// Modify image color: contrast (-100 to 100)
fn void image_color_contrast(Image* image, float contrast) @extern("ImageColorContrast");
// Modify image color: brightness (-255 to 255)
fn void image_color_brightness(Image* image, int brightness) @extern("ImageColorBrightness");
// Modify image color: replace color
fn void image_color_replace(Image* image, Color color, Color replace) @extern("ImageColorReplace");
// Load color data from image as a Color array (RGBA - 32bit)
fn Color* load_image_colors(Image image) @extern("LoadImageColors");
// Load colors palette from image as a Color array (RGBA - 32bit)
fn Color* load_image_palette(Image image, int max_palette_size, int *color_count) @extern("LoadImagePalette");
// Unload color data loaded with LoadImageColors()
fn void unload_image_colors(Color* colors) @extern("UnloadImageColors");
// Unload colors palette loaded with LoadImagePalette()
fn void unload_image_palette(Color* colors) @extern("UnloadImagePalette");
// Get image alpha border rectangle
fn Rectangle get_image_alpha_border(Image image, float threshold) @extern("GetImageAlphaBorder");
// Get image pixel color at (x, y) position
fn Color get_image_color(Image image, int x, int y) @extern("GetImageColor");

// Image drawing functions
// NOTE: Image software-rendering functions (CPU)
//------------------------------------------------------------------------------------
// Clear image background with given color
fn void image_clear_background(Image* dst, Color color) @extern("ImageClearBackground");
// Draw pixel within an image
fn void image_draw_pixel(Image* dst, int pos_x, int pos_y, Color color) @extern("ImageDrawPixel");
// Draw pixel within an image (Vector version)
fn void image_draw_pixel_v(Image* dst, Vector2 position, Color color) @extern("ImageDrawPixelV");
// Draw line within an image
fn void image_draw_line(Image* dst, int start_pos_x, int start_pos_y, int end_pos_x, int end_pos_y, Color color) @extern("ImageDrawLine");
// Draw line within an image (Vector version)
fn void image_draw_line_v(Image* dst, Vector2 start, Vector2 end, Color color) @extern("ImageDrawLineV");
// Draw a filled circle within an image
fn void image_draw_circle(Image* dst, int center_x, int center_y, int radius, Color color) @extern("ImageDrawCircle");
// Draw a filled circle within an image (Vector version)
fn void image_draw_circle_v(Image* dst, Vector2 center, int radius, Color color) @extern("ImageDrawCircleV");
// Draw circle outline within an image
fn void image_draw_circle_lines(Image* dst, int center_x, int center_y, int radius, Color color) @extern("ImageDrawCircleLines");
// Draw circle outline within an image (Vector version)
fn void image_draw_circle_lines_v(Image* dst, Vector2 center, int radius, Color color) @extern("ImageDrawCircleLinesV");
// Draw rectangle within an image
fn void image_draw_rectangle(Image* dst, int pos_x, int pos_y, int width, int height, Color color) @extern("ImageDrawRectangle");
// Draw rectangle within an image (Vector version)
fn void image_draw_rectangle_v(Image* dst, Vector2 position, Vector2 size, Color color) @extern("ImageDrawRectangleV");
// Draw rectangle within an image
fn void image_draw_rectangle_rec(Image* dst, Rectangle rec, Color color) @extern("ImageDrawRectangleRec");
// Draw rectangle lines within an image
fn void image_draw_rectangle_lines(Image* dst, Rectangle rec, int thick, Color color) @extern("ImageDrawRectangleLines");
// Draw a source image within a destination image (tint applied to source)
fn void image_draw(Image* dst, Image src, Rectangle src_rec, Rectangle dst_rec, Color tint) @extern("ImageDraw");
// Draw text (using default font) within an image (destination)
fn void image_draw_text(Image* dst, ZString text, int pos_x, int pos_y, int font_size, Color color) @extern("ImageDrawText");
// Draw text (custom sprite font) within an image (destination)
fn void image_draw_text_ex(Image* dst, Font font, ZString text, Vector2 position, float font_size, float spacing, Color tint) @extern("ImageDrawTextEx");

// Texture loading functions
// NOTE: These functions require GPU access
//------------------------------------------------------------------------------------
// Load texture from file into GPU memory (VRAM)
fn Texture2D load_texture(ZString file_name) @extern("LoadTexture");
// Load texture from image data
fn Texture2D load_texture_from_image(Image image) @extern("LoadTextureFromImage");
// Load cubemap from image, multiple image cubemap layouts supported
fn TextureCubemap load_texture_cubemap(Image image, int layout) @extern("LoadTextureCubemap");
// Load texture for rendering (framebuffer)
fn RenderTexture2D load_render_texture(int width, int height) @extern("LoadRenderTexture");
// Check if a texture is ready
fn bool is_texture_ready(Texture2D texture) @extern("IsTextureReady");
// Unload texture from GPU memory (VRAM)
fn void unload_texture(Texture2D texture) @extern("UnloadTexture");
// Check if a render texture is ready
fn bool is_render_texture_ready(RenderTexture2D target) @extern("IsRenderTextureReady");
// Unload render texture from GPU memory (VRAM)
fn void unload_render_texture(RenderTexture2D target) @extern("UnloadRenderTexture");
// Update GPU texture with new data
fn void update_texture(Texture2D texture, void* pixels) @extern("UpdateTexture");
// Update GPU texture rectangle with new data
fn void update_texture_rec(Texture2D texture, Rectangle rec, void* pixels) @extern("UpdateTextureRec");

// Texture configuration functions
//------------------------------------------------------------------------------------
// Generate GPU mipmaps for a texture
fn void gen_texture_mipmaps(Texture2D* texture) @extern("GenTextureMipmaps");
// Set texture scaling filter mode
fn void set_texture_filter(Texture2D texture, int filter) @extern("SetTextureFilter");
// Set texture wrapping mode
fn void set_texture_wrap(Texture2D texture, int wrap) @extern("SetTextureWrap");

// Texture drawing functions
//------------------------------------------------------------------------------------
// Draw a Texture2D
fn void draw_texture(Texture2D texture, int pos_x, int pos_y, Color tint) @extern("DrawTexture");
// Draw a Texture2D with position defined as Vector2
fn void draw_texture_v(Texture2D texture, Vector2 position, Color tint) @extern("DrawTextureV");
// Draw a Texture2D with extended parameters
fn void draw_texture_ex(Texture2D texture, Vector2 position, float rotation, float scale, Color tint) @extern("DrawTextureEx");
// Draw a part of a texture defined by a rectangle
fn void draw_texture_rec(Texture2D texture, Rectangle source, Vector2 position, Color tint) @extern("DrawTextureRec");
// Draw a part of a texture defined by a rectangle with 'pro' parameters
fn void draw_texture_pro(Texture2D texture, Rectangle source, Rectangle dest, Vector2 origin, float rotation, Color tint) @extern("DrawTexturePro");
// Draws a texture (or part of it) that stretches or shrinks nicely
fn void draw_texture_n_patch(Texture2D texture, NPatchInfo n_patch_info, Rectangle dest, Vector2 origin, float rotation, Color tint) @extern("DrawTextureNPatch");

// Color/pixel related functions
//------------------------------------------------------------------------------------
// Get color with alpha applied, alpha goes from 0.0f to 1.0f
fn Color fade(Color color, float alpha) @extern("Fade");
// Get hexadecimal value for a Color
fn int color_to_int(Color color) @extern("ColorToInt");
// Get Color normalized as float [0..1]
fn Vector4 color_normalize(Color color) @extern("ColorNormalize");
// Get Color from normalized values [0..1]
fn Color color_from_normalized(Vector4 normalized) @extern("ColorFromNormalized");
// Get HSV values for a Color, hue [0..360], saturation/value [0..1]
fn Vector3 color_to_hsv(Color color) @extern("ColorToHSV");
// Get a Color from HSV values, hue [0..360], saturation/value [0..1]
fn Color color_from_hsv(float hue, float saturation, float value) @extern("ColorFromHSV");
// Get color multiplied with another color
fn Color color_tint(Color color, Color tint) @extern("ColorTint");
// Get color with brightness correction, brightness factor goes from -1.0f to 1.0f
fn Color color_brightness(Color color, float factor) @extern("ColorBrightness");
// Get color with contrast correction, contrast values between -1.0f and 1.0f
fn Color color_contrast(Color color, float contrast) @extern("ColorContrast");
// Get color with alpha applied, alpha goes from 0.0f to 1.0f
fn Color color_alpha(Color color, float alpha) @extern("ColorAlpha");
// Get src alpha-blended into dst color with tint
fn Color color_alpha_blend(Color dst, Color src, Color tint) @extern("ColorAlphaBlend");
// Get Color structure from hexadecimal value
fn Color get_color(uint hex_value) @extern("GetColor");
// Get Color from a source pixel pointer of certain format
fn Color get_pixel_color(void* src_ptr, int format) @extern("GetPixelColor");
// Set color formatted into destination pixel pointer
fn void set_pixel_color(void* dst_ptr, Color color, int format) @extern("SetPixelColor");
// Get pixel data size in bytes for certain format
fn int get_pixel_data_size(int width, int height, int format) @extern("GetPixelDataSize");

//------------------------------------------------------------------------------------
// Font Loading and Text Drawing Functions (Module: text)
//------------------------------------------------------------------------------------

// Font loading/unloading functions
//------------------------------------------------------------------------------------
// Get the default Font
fn Font get_font_default() @extern("GetFontDefault");
// Load font from file into GPU memory (VRAM)
fn Font load_font(ZString file_name) @extern("LoadFont");
// Load font from file with extended parameters, use NULL for codepoints and 0 for codepointCount to load the default character set
fn Font load_font_ex(ZString file_name, int font_size, int *codepoints, int codepoint_count) @extern("LoadFontEx");
// Load font from Image (XNA style)
fn Font load_font_from_image(Image image, Color key, int first_char) @extern("LoadFontFromImage");
// Load font from memory buffer, fileType refers to extension: i.e. '.ttf'
fn Font load_font_from_memory(ZString file_type, ZString file_data, int data_size, int fontSize, int *codepoints, int codepoint_count) @extern("LoadFontFromMemory");
// Check if a font is ready
fn bool is_font_ready(Font font) @extern("IsFontReady");
// Load font data for further use
fn GlyphInfo* load_font_data(ZString file_data, int data_size, int font_size, int *codepoints, int codepoint_count, int type) @extern("LoadFontData");
// Generate image font atlas using chars info
fn Image gen_image_font_atlas(GlyphInfo* glyphs, Rectangle **glyph_recs, int glyph_count, int fontSize, int padding, int pack_method) @extern("GenImageFontAtlas");
// Unload font chars info data (RAM)
fn void unload_font_data(GlyphInfo* glyphs, int glyph_count) @extern("UnloadFontData");
// Unload font from GPU memory (VRAM)
fn void unload_font(Font font) @extern("UnloadFont");
// Export font as code file, returns true on success
fn bool export_font_as_code(Font font, ZString file_name) @extern("ExportFontAsCode");

// Text drawing functions
//------------------------------------------------------------------------------------
// Draw current FPS
fn void draw_fps(int pos_x, int pos_y) @extern("DrawFPS");
// Draw text (using default font)
fn void draw_text(ZString text, int pos_x, int pos_y, int font_size, Color color) @extern("DrawText");
// Draw text using font and additional parameters
fn void draw_text_ex(Font font, ZString text, Vector2 position, float font_size, float spacing, Color tint) @extern("DrawTextEx");
// Draw text using Font and pro parameters (rotation)
fn void draw_text_pro(Font font, ZString text, Vector2 position, Vector2 origin, float rotation, float font_size, float spacing, Color tint) @extern("DrawTextPro");
// Draw one character (codepoint)
fn void draw_text_codepoint(Font font, int codepoint, Vector2 position, float font_size, Color tint) @extern("DrawTextCodepoint");
// Draw multiple character (codepoint)
fn void draw_text_codepoints(Font font, int* codepoints, int codepoint_count, Vector2 position, float font_size, float spacing, Color tint) @extern("DrawTextCodepoints");

// Text font info functions
//------------------------------------------------------------------------------------
// Set vertical line spacing when drawing with line-breaks
fn void set_text_line_spacing(int spacing) @extern("SetTextLineSpacing");
// Measure string width for default font
fn int measure_text(ZString text, int font_size) @extern("MeasureText");
// Measure string size for Font
fn Vector2 measure_text_ex(Font font, ZString text, float font_size, float spacing) @extern("MeasureTextEx");
// Get glyph index position in font for a codepoint (unicode character), fallback to '?' if not found
fn int get_glyph_index(Font font, int codepoint) @extern("GetGlyphIndex");
// Get glyph font info data for a codepoint (unicode character), fallback to '?' if not found
fn GlyphInfo get_glyph_info(Font font, int codepoint) @extern("GetGlyphInfo");
// Get glyph rectangle in font atlas for a codepoint (unicode character), fallback to '?' if not found
fn Rectangle get_glyph_atlas_rec(Font font, int codepoint) @extern("GetGlyphAtlasRec");

// Text codepoints management functions (unicode characters)
//------------------------------------------------------------------------------------
// Load UTF-8 text encoded from codepoints array
fn char* load_utf8(int *codepoints, int length) @extern("LoadUTF8");
// Unload UTF-8 text encoded from codepoints array
fn void unload_utf8(char* text) @extern("UnloadUTF8");
// Load all codepoints from a UTF-8 text string, codepoints count returned by parameter
fn int* load_codepoints(ZString text, int *count) @extern("LoadCodepoints");
// Unload codepoints data from memory
fn void unload_codepoints(int* codepoints) @extern("UnloadCodepoints");
// Get total number of codepoints in a UTF-8 encoded string
fn int get_codepoint_count(ZString text) @extern("GetCodepointCount");
// Get next codepoint in a UTF-8 encoded string, 0x3f('?') is returned on failure
fn int get_codepoint(ZString text, int *codepoint_size) @extern("GetCodepoint");
// Get next codepoint in a UTF-8 encoded string, 0x3f('?') is returned on failure
fn int get_codepoint_next(ZString text, int *codepoint_size) @extern("GetCodepointNext");
// Get previous codepoint in a UTF-8 encoded string, 0x3f('?') is returned on failure
fn int get_codepoint_previous(ZString text, int *codepoint_size) @extern("GetCodepointPrevious");
// Encode one codepoint into UTF-8 byte array (array length returned as parameter)
fn ZString codepoint_to_utf8(int codepoint, int *utf8_size) @extern("CodepointToUTF8");

// Text strings management functions (no UTF-8 strings, only byte chars)
// NOTE: Some strings allocate memory internally for returned strings, just be careful!
//------------------------------------------------------------------------------------
// Copy one string to another, returns bytes copied
fn int text_copy(ZString dst, ZString src) @extern("TextCopy");
// Check if two text string are equal
fn bool text_is_equal(ZString text1, ZString text2) @extern("TextIsEqual");
// Get text length, checks for '\0' ending
fn uint text_length(ZString text) @extern("TextLength");
// Text formatting with variables (sprintf() style)
fn ZString text_format(ZString text, ...) @extern("TextFormat");
// Get a piece of a text string
fn ZString text_subtext(ZString text, int position, int length) @extern("TextSubtext");
// Replace text string (WARNING: memory must be freed!)
fn char* text_replace(char *text, ZString replace, ZString by) @extern("TextReplace");
// Insert text in a position (WARNING: memory must be freed!)
fn char* text_insert(ZString text, ZString insert, int position) @extern("TextInsert");
// Join text strings with delimiter
fn ZString text_join(ZString *text_list, int count, ZString delimiter) @extern("TextJoin");
// Split text into multiple strings
fn ZString *text_split(ZString text, char delimiter, int *count) @extern("TextSplit");
// Append text at specific position and move cursor!
fn void text_append(char* text, ZString append, int *position) @extern("TextAppend");
// Find first text occurrence within a string
fn int text_find_index(ZString text, ZString find) @extern("TextFindIndex");
// Get upper case version of provided string
fn ZString text_to_upper(ZString text) @extern("TextToUpper");
// Get lower case version of provided string
fn ZString text_to_lower(ZString text) @extern("TextToLower");
// Get Pascal case notation version of provided string
fn ZString text_to_pascal(ZString text) @extern("TextToPascal");
// Get integer value from text (negative values not supported)
fn int text_to_integer(ZString text) @extern("TextToInteger");

//------------------------------------------------------------------------------------
// Basic 3d Shapes Drawing Functions (Module: models)
//------------------------------------------------------------------------------------

// Basic geometric 3D shapes drawing functions
//------------------------------------------------------------------------------------
// Draw a line in 3D world space
fn void draw_line3_d(Vector3 start_pos, Vector3 end_pos, Color color) @extern("DrawLine3D");
// Draw a point in 3D space, actually a small line
fn void draw_point3_d(Vector3 position, Color color) @extern("DrawPoint3D");
// Draw a circle in 3D world space
fn void draw_circle3_d(Vector3 center, float radius, Vector3 rotation_axis, float rotation_angle, Color color) @extern("DrawCircle3D");
// Draw a color-filled triangle (vertex in counter-clockwise order!)
fn void draw_triangle3_d(Vector3 v1, Vector3 v2, Vector3 v3, Color color) @extern("DrawTriangle3D");
// Draw a triangle strip defined by points
fn void draw_triangle_strip3_d(Vector3* points, int point_count, Color color) @extern("DrawTriangleStrip3D");
// Draw cube
fn void draw_cube(Vector3 position, float width, float height, float length, Color color) @extern("DrawCube");
// Draw cube (Vector version)
fn void draw_cube_v(Vector3 position, Vector3 size, Color color) @extern("DrawCubeV");
// Draw cube wires
fn void draw_cube_wires(Vector3 position, float width, float height, float length, Color color) @extern("DrawCubeWires");
// Draw cube wires (Vector version)
fn void draw_cube_wires_v(Vector3 position, Vector3 size, Color color) @extern("DrawCubeWiresV");
// Draw sphere
fn void draw_sphere(Vector3 center_pos, float radius, Color color) @extern("DrawSphere");
// Draw sphere with extended parameters
fn void draw_sphere_ex(Vector3 center_pos, float radius, int rings, int slices, Color color) @extern("DrawSphereEx");
// Draw sphere wires
fn void draw_sphere_wires(Vector3 center_pos, float radius, int rings, int slices, Color color) @extern("DrawSphereWires");
// Draw a cylinder/cone
fn void draw_cylinder(Vector3 position, float radius_top, float radius_bottom, float height, int slices, Color color) @extern("DrawCylinder");
// Draw a cylinder with base at startPos and top at endPos
fn void draw_cylinder_ex(Vector3 start_pos, Vector3 end_pos, float start_radius, float end_radius, int sides, Color color) @extern("DrawCylinderEx");
// Draw a cylinder/cone wires
fn void draw_cylinder_wires(Vector3 position, float radius_top, float radius_bottom, float height, int slices, Color color) @extern("DrawCylinderWires");
// Draw a cylinder wires with base at startPos and top at endPos
fn void draw_cylinder_wires_ex(Vector3 startPos, Vector3 end_pos, float start_radius, float end_radius, int sides, Color color) @extern("DrawCylinderWiresEx");
// Draw a capsule with the center of its sphere caps at startPos and endPos
fn void draw_capsule(Vector3 start_pos, Vector3 endPos, float radius, int slices, int rings, Color color) @extern("DrawCapsule");
// Draw capsule wireframe with the center of its sphere caps at startPos and endPos
fn void draw_capsule_wires(Vector3 start_pos, Vector3 endPos, float radius, int slices, int rings, Color color) @extern("DrawCapsuleWires");
// Draw a plane XZ
fn void draw_plane(Vector3 center_pos, Vector2 size, Color color) @extern("DrawPlane");
// Draw a ray line
fn void draw_ray(Ray ray, Color color) @extern("DrawRay");
// Draw a grid (centered at (0, 0, 0))
fn void draw_grid(int slices, float spacing) @extern("DrawGrid");

//------------------------------------------------------------------------------------
// Model 3d Loading and Drawing Functions (Module: models)
//------------------------------------------------------------------------------------

// Model management functions
//------------------------------------------------------------------------------------
// Load model from files (meshes and materials)
fn Model load_model(ZString file_name) @extern("LoadModel");
// Load model from generated mesh (default material)
fn Model load_model_from_mesh(Mesh mesh) @extern("LoadModelFromMesh");
// Check if a model is ready
fn bool is_model_ready(Model model) @extern("IsModelReady");
// Unload model (including meshes) from memory (RAM and/or VRAM)
fn void unload_model(Model model) @extern("UnloadModel");
// Compute model bounding box limits (considers all meshes)
fn BoundingBox get_model_bounding_box(Model model) @extern("GetModelBoundingBox");

// Model drawing functions
//------------------------------------------------------------------------------------
// Draw a model (with texture if set)
fn void draw_model(Model model, Vector3 position, float scale, Color tint) @extern("DrawModel");
// Draw a model with extended parameters
fn void draw_model_ex(Model model, Vector3 position, Vector3 rotation_axis, float rotation_angle, Vector3 scale, Color tint) @extern("DrawModelEx");
// Draw a model wires (with texture if set)
fn void draw_model_wires(Model model, Vector3 position, float scale, Color tint) @extern("DrawModelWires");
// Draw a model wires (with texture if set) with extended parameters
fn void draw_model_wires_ex(Model model, Vector3 position, Vector3 rotation_axis, float rotation_angle, Vector3 scale, Color tint) @extern("DrawModelWiresEx");
// Draw bounding box (wires)
fn void draw_bounding_box(BoundingBox box, Color color) @extern("DrawBoundingBox");
// Draw a billboard texture
fn void draw_billboard(Camera camera, Texture2D texture, Vector3 position, float size, Color tint) @extern("DrawBillboard");
// Draw a billboard texture defined by source
fn void draw_billboard_rec(Camera camera, Texture2D texture, Rectangle source, Vector3 position, Vector2 size, Color tint) @extern("DrawBillboardRec");
// Draw a billboard texture defined by source and rotation
fn void draw_billboard_pro(Camera camera, Texture2D texture, Rectangle source, Vector3 position, Vector3 up, Vector2 size, Vector2 origin, float rotation, Color tint) @extern("DrawBillboardPro");

// Mesh management functions
//------------------------------------------------------------------------------------
// Upload mesh vertex data in GPU and provide VAO/VBO ids
fn void upload_mesh(Mesh* mesh, bool dynamic) @extern("UploadMesh");
// Update mesh vertex data in GPU for a specific buffer index
fn void update_mesh_buffer(Mesh mesh, int index, void* data, int data_size, int offset) @extern("UpdateMeshBuffer");
// Unload mesh data from CPU and GPU
fn void unload_mesh(Mesh mesh) @extern("UnloadMesh");
// Draw a 3d mesh with material and transform
fn void draw_mesh(Mesh mesh, Material material, Matrix transform) @extern("DrawMesh");
// Draw multiple mesh instances with material and different transforms
fn void draw_mesh_instanced(Mesh mesh, Material material, Matrix* transforms, int instances) @extern("DrawMeshInstanced");
// Export mesh data to file, returns true on success
fn bool export_mesh(Mesh mesh, ZString file_name) @extern("ExportMesh");
// Compute mesh bounding box limits
fn BoundingBox get_mesh_bounding_box(Mesh mesh) @extern("GetMeshBoundingBox");
// Compute mesh tangents
fn void gen_mesh_tangents(Mesh* mesh) @extern("GenMeshTangents");

// Mesh generation functions
//------------------------------------------------------------------------------------
// Generate polygonal mesh
fn Mesh gen_mesh_poly(int sides, float radius) @extern("GenMeshPoly");
// Generate plane mesh (with subdivisions)
fn Mesh gen_mesh_plane(float width, float length, int res_x, int res_z) @extern("GenMeshPlane");
// Generate cuboid mesh
fn Mesh gen_mesh_cube(float width, float height, float length) @extern("GenMeshCube");
// Generate sphere mesh (standard sphere)
fn Mesh gen_mesh_sphere(float radius, int rings, int slices) @extern("GenMeshSphere");
// Generate half-sphere mesh (no bottom cap)
fn Mesh gen_mesh_hemi_sphere(float radius, int rings, int slices) @extern("GenMeshHemiSphere");
// Generate cylinder mesh
fn Mesh gen_mesh_cylinder(float radius, float height, int slices) @extern("GenMeshCylinder");
// Generate cone/pyramid mesh
fn Mesh gen_mesh_cone(float radius, float height, int slices) @extern("GenMeshCone");
// Generate torus mesh
fn Mesh gen_mesh_torus(float radius, float size, int rad_seg, int sides) @extern("GenMeshTorus");
// Generate trefoil knot mesh
fn Mesh gen_mesh_knot(float radius, float size, int rad_seg, int sides) @extern("GenMeshKnot");
// Generate heightmap mesh from image data
fn Mesh gen_mesh_heightmap(Image heightmap, Vector3 size) @extern("GenMeshHeightmap");
// Generate cubes-based map mesh from image data
fn Mesh gen_mesh_cubicmap(Image cubicmap, Vector3 cube_size) @extern("GenMeshCubicmap");

// Material loading/unloading functions
//------------------------------------------------------------------------------------
// Load materials from model file
fn Material* load_materials(ZString file_name, int *material_count) @extern("LoadMaterials");
// Load default material (Supports: DIFFUSE, SPECULAR, NORMAL maps)
fn Material load_material_default() @extern("LoadMaterialDefault");
// Check if a material is ready
fn bool is_material_ready(Material material) @extern("IsMaterialReady");
// Unload material from GPU memory (VRAM)
fn void unload_material(Material material) @extern("UnloadMaterial");
// Set texture for a material map type (MATERIAL_MAP_DIFFUSE, MATERIAL_MAP_SPECULAR...)
fn void set_material_texture(Material* material, int map_type, Texture2D texture) @extern("SetMaterialTexture");
// Set material for a mesh
fn void set_model_mesh_material(Model* model, int mesh_id, int material_id) @extern("SetModelMeshMaterial");

// Model animations loading/unloading functions
//------------------------------------------------------------------------------------
// Load model animations from file
fn ModelAnimation* load_model_animations(ZString file_name, int *anim_count) @extern("LoadModelAnimations");
// Update model animation pose
fn void update_model_animation(Model model, ModelAnimation anim, int frame) @extern("UpdateModelAnimation");
// Unload animation data
fn void unload_model_animation(ModelAnimation anim) @extern("UnloadModelAnimation");
// Unload animation array data
fn void unload_model_animations(ModelAnimation* animations, int anim_count) @extern("UnloadModelAnimations");
// Check model animation skeleton match
fn bool is_model_animation_valid(Model model, ModelAnimation anim) @extern("IsModelAnimationValid");

// Collision detection functions
//------------------------------------------------------------------------------------
// Check collision between two spheres
fn bool check_collision_spheres(Vector3 center1, float radius1, Vector3 center2, float radius2) @extern("CheckCollisionSpheres");
// Check collision between two bounding boxes
fn bool check_collision_boxes(BoundingBox box1, BoundingBox box2) @extern("CheckCollisionBoxes");
// Check collision between box and sphere
fn bool check_collision_box_sphere(BoundingBox box, Vector3 center, float radius) @extern("CheckCollisionBoxSphere");
// Get collision info between ray and sphere
fn RayCollision get_ray_collision_sphere(Ray ray, Vector3 center, float radius) @extern("GetRayCollisionSphere");
// Get collision info between ray and box
fn RayCollision get_ray_collision_box(Ray ray, BoundingBox box) @extern("GetRayCollisionBox");
// Get collision info between ray and mesh
fn RayCollision get_ray_collision_mesh(Ray ray, Mesh mesh, Matrix transform) @extern("GetRayCollisionMesh");
// Get collision info between ray and triangle
fn RayCollision get_ray_collision_triangle(Ray ray, Vector3 p1, Vector3 p2, Vector3 p3) @extern("GetRayCollisionTriangle");
// Get collision info between ray and quad
fn RayCollision get_ray_collision_quad(Ray ray, Vector3 p1, Vector3 p2, Vector3 p3, Vector3 p4) @extern("GetRayCollisionQuad");

//------------------------------------------------------------------------------------
// Audio Loading and Playing Functions (Module: audio)
//------------------------------------------------------------------------------------
def AudioCallback = fn void(void* buffer_data, uint frames);

// Audio device management functions
//------------------------------------------------------------------------------------
// Initialize audio device and context
fn void init_audio_device() @extern("InitAudioDevice");
// Close the audio device and context
fn void close_audio_device() @extern("CloseAudioDevice");
// Check if audio device has been initialized successfully
fn bool is_audio_device_ready() @extern("IsAudioDeviceReady");
// Set master volume (listener)
fn void set_master_volume(float volume) @extern("SetMasterVolume");
// Get master volume (listener)
fn float get_master_volume() @extern("GetMasterVolume");

// Wave/Sound loading/unloading functions
//------------------------------------------------------------------------------------
// Load wave data from file
fn Wave load_wave(ZString file_name) @extern("LoadWave");
// Load wave from memory buffer, fileType refers to extension: i.e. '.wav'
fn Wave load_wave_from_memory(ZString file_type, ZString file_data, int data_size) @extern("LoadWaveFromMemory");
// Checks if wave data is ready
fn bool is_wave_ready(Wave wave) @extern("IsWaveReady");
// Load sound from file
fn Sound load_sound(ZString file_name) @extern("LoadSound");
// Load sound from wave data
fn Sound load_sound_from_wave(Wave wave) @extern("LoadSoundFromWave");
// Create a new sound that shares the same sample data as the source sound, does not own the sound data
fn Sound load_sound_alias(Sound source) @extern("LoadSoundAlias");
// Checks if a sound is ready
fn bool is_sound_ready(Sound sound) @extern("IsSoundReady");
// Update sound buffer with new data
fn void update_sound(Sound sound, void* data, int sample_count) @extern("UpdateSound");
// Unload wave data
fn void unload_wave(Wave wave) @extern("UnloadWave");
// Unload sound
fn void unload_sound(Sound sound) @extern("UnloadSound");
// Unload a sound alias (does not deallocate sample data)
fn void unload_sound_alias(Sound alias) @extern("UnloadSoundAlias");
// Export wave data to file, returns true on success
fn bool export_wave(Wave wave, ZString file_name) @extern("ExportWave");
// Export wave sample data to code (.h), returns true on success
fn bool export_wave_as_code(Wave wave, ZString file_name) @extern("ExportWaveAsCode");

// Wave/Sound management functions
//------------------------------------------------------------------------------------
// Play a sound
fn void play_sound(Sound sound) @extern("PlaySound");
// Stop playing a sound
fn void stop_sound(Sound sound) @extern("StopSound");
// Pause a sound
fn void pause_sound(Sound sound) @extern("PauseSound");
// Resume a paused sound
fn void resume_sound(Sound sound) @extern("ResumeSound");
// Check if a sound is currently playing
fn bool is_sound_playing(Sound sound) @extern("IsSoundPlaying");
// Set volume for a sound (1.0 is max level)
fn void set_sound_volume(Sound sound, float volume) @extern("SetSoundVolume");
// Set pitch for a sound (1.0 is base level)
fn void set_sound_pitch(Sound sound, float pitch) @extern("SetSoundPitch");
// Set pan for a sound (0.5 is center)
fn void set_sound_pan(Sound sound, float pan) @extern("SetSoundPan");
// Copy a wave to a new wave
fn Wave wave_copy(Wave wave) @extern("WaveCopy");
// Crop a wave to defined samples range
fn void wave_crop(Wave* wave, int init_sample, int final_sample) @extern("WaveCrop");
// Convert wave data to desired format
fn void wave_format(Wave* wave, int sample_rate, int sample_size, int channels) @extern("WaveFormat");
// Load samples data from wave as a 32bit float data array
fn float* load_wave_samples(Wave wave) @extern("LoadWaveSamples");
// Unload samples data loaded with LoadWaveSamples()
fn void unload_wave_samples(float* samples) @extern("UnloadWaveSamples");

// Music management functions
//------------------------------------------------------------------------------------
// Load music stream from file
fn Music load_music_stream(ZString file_name) @extern("LoadMusicStream");
// Load music stream from data
fn Music load_music_stream_from_memory(ZString file_type, ZString data, int data_size) @extern("LoadMusicStreamFromMemory");
// Checks if a music stream is ready
fn bool is_music_ready(Music music) @extern("IsMusicReady");
// Unload music stream
fn void unload_music_stream(Music music) @extern("UnloadMusicStream");
// Start music playing
fn void play_music_stream(Music music) @extern("PlayMusicStream");
// Check if music is playing
fn bool is_music_stream_playing(Music music) @extern("IsMusicStreamPlaying");
// Updates buffers for music streaming
fn void update_music_stream(Music music) @extern("UpdateMusicStream");
// Stop music playing
fn void stop_music_stream(Music music) @extern("StopMusicStream");
// Pause music playing
fn void pause_music_stream(Music music) @extern("PauseMusicStream");
// Resume playing paused music
fn void resume_music_stream(Music music) @extern("ResumeMusicStream");
// Seek music to a position (in seconds)
fn void seek_music_stream(Music music, float position) @extern("SeekMusicStream");
// Set volume for music (1.0 is max level)
fn void set_music_volume(Music music, float volume) @extern("SetMusicVolume");
// Set pitch for a music (1.0 is base level)
fn void set_music_pitch(Music music, float pitch) @extern("SetMusicPitch");
// Set pan for a music (0.5 is center)
fn void set_music_pan(Music music, float pan) @extern("SetMusicPan");
// Get music time length (in seconds)
fn float get_music_time_length(Music music) @extern("GetMusicTimeLength");
// Get current music time played (in seconds)
fn float get_music_time_played(Music music) @extern("GetMusicTimePlayed");

// AudioStream management functions
//------------------------------------------------------------------------------------
// Load audio stream (to stream raw audio pcm data)
fn AudioStream load_audio_stream(uint sample_rate, uint sample_size, uint channels) @extern("LoadAudioStream");
// Checks if an audio stream is ready
fn bool is_audio_stream_ready(AudioStream stream) @extern("IsAudioStreamReady");
// Unload audio stream and free memory
fn void unload_audio_stream(AudioStream stream) @extern("UnloadAudioStream");
// Update audio stream buffers with data
fn void update_audio_stream(AudioStream stream, void* data, int frameCount) @extern("UpdateAudioStream");
// Check if any audio stream buffers requires refill
fn bool is_audio_stream_processed(AudioStream stream) @extern("IsAudioStreamProcessed");
// Play audio stream
fn void play_audio_stream(AudioStream stream) @extern("PlayAudioStream");
// Pause audio stream
fn void pause_audio_stream(AudioStream stream) @extern("PauseAudioStream");
// Resume audio stream
fn void resume_audio_stream(AudioStream stream) @extern("ResumeAudioStream");
// Check if audio stream is playing
fn bool is_audio_stream_playing(AudioStream stream) @extern("IsAudioStreamPlaying");
// Stop audio stream
fn void stop_audio_stream(AudioStream stream) @extern("StopAudioStream");
// Set volume for audio stream (1.0 is max level)
fn void set_audio_stream_volume(AudioStream stream, float volume) @extern("SetAudioStreamVolume");
// Set pitch for audio stream (1.0 is base level)
fn void set_audio_stream_pitch(AudioStream stream, float pitch) @extern("SetAudioStreamPitch");
// Set pan for audio stream (0.5 is centered)
fn void set_audio_stream_pan(AudioStream stream, float pan) @extern("SetAudioStreamPan");
// Default size for new audio streams
fn void set_audio_stream_buffer_size_default(int size) @extern("SetAudioStreamBufferSizeDefault");
// Audio thread callback to request new data
fn void set_audio_stream_callback(AudioStream stream, AudioCallback callback) @extern("SetAudioStreamCallback");

// Attach audio stream processor to stream, receives the samples as <float>s
fn void attach_audio_stream_processor(AudioStream stream, AudioCallback processor) @extern("AttachAudioStreamProcessor");
// Detach audio stream processor from stream
fn void detach_audio_stream_processor(AudioStream stream, AudioCallback processor) @extern("DetachAudioStreamProcessor");

// Attach audio stream processor to the entire audio pipeline, receives the samples as <float>s
fn void attach_audio_mixed_processor(AudioCallback processor) @extern("AttachAudioMixedProcessor");
// Detach audio stream processor from the entire audio pipeline
fn void detach_audio_mixed_processor(AudioCallback processor) @extern("DetachAudioMixedProcessor");

